diff --git a/misc/m4/tm_platform.m4 b/misc/m4/tm_platform.m4
index 8c66d59..f9d6c6f 100644
--- a/misc/m4/tm_platform.m4
+++ b/misc/m4/tm_platform.m4
@@ -101,7 +101,7 @@ AC_DEFUN([TM_PLATFORM],[
       CONFIG_CXXOPTIMIZE="-O3 -fexpensive-optimizations"
       CONFIG_QTPIPES="yes"
       CONFIG_OS_COMPAT="Windows"
-      CPPFLAGS="$CPPFLAGS -I/usr/local/include -I."
+      CPPFLAGS="$CPPFLAGS -I/usr/local/include -IPlugins/Windows -I."
       GUILE_LDFLAGS="-lmingwex $GUILE_LDFLAGS -lintl" #added mingwex to mask the internal guile readdir function
       LC_APPEND_FLAG([-Wl,--stack=16777216],[LDFLAGS])
     ;;
diff --git a/src/Data/String/converter.cpp b/src/Data/String/converter.cpp
index 5c55adf..43db989 100644
--- a/src/Data/String/converter.cpp
+++ b/src/Data/String/converter.cpp
@@ -482,15 +482,6 @@ cork_to_ascii (string input) {
   return apply (conv, input);
 }
 
-#ifndef QTTEXMACS
-string
-cork_to_os8bits (const string s){
-  // return convert(s , "Cork", get_locale_charset ());
-  // since this is X11 we can assume locale_charset==UTF8
-  return convert(s , "Cork", "UTF-8");  
-}
-#endif
-
 
 #ifdef USE_ICONV
 
diff --git a/src/Data/String/converter.hpp b/src/Data/String/converter.hpp
index 772753d..2c91d71 100644
--- a/src/Data/String/converter.hpp
+++ b/src/Data/String/converter.hpp
@@ -88,7 +88,6 @@ string t2a_to_utf8 (string input);
 string cyrillic_subset_in_t2a_to_code_point (string input);
 string code_point_to_cyrillic_subset_in_t2a (string input);
 string cork_to_ascii (string input);
-string cork_to_os8bits (string s);
 bool check_using_iconv (string input, string encoding);
 string convert_using_iconv (string input, string from, string to); 
 
diff --git a/src/Edit/Modify/edit_text.cpp b/src/Edit/Modify/edit_text.cpp
index 669f900..84acf62 100644
--- a/src/Edit/Modify/edit_text.cpp
+++ b/src/Edit/Modify/edit_text.cpp
@@ -362,11 +362,12 @@ edit_text_rep::make_image (
   tree t (IMAGE);
   if (link) {
     if (is_rooted (image, "default")) image= reroot (image, "file");
-    t << as_string (image, URL_STANDARD);
+    // here we convert the filename to cork-universal because it is exposed in the document, in the <image> tag
+    t << utf8_to_cork (as_string (image, URL_STANDARD));
   }
   else {
     string s;
-    tree vim= verbatim (as_string (image));
+    tree vim= verbatim (utf8_to_cork (as_string (image)));
     load_string (relative (get_name (), image), s, false);
     if (s == "") {
       set_message (concat ("File '", vim, "' not found"), "make image");
diff --git a/src/Plugins/Pdf/pdf_hummus_renderer.cpp b/src/Plugins/Pdf/pdf_hummus_renderer.cpp
index 01fdf54..3b3f341 100644
--- a/src/Plugins/Pdf/pdf_hummus_renderer.cpp
+++ b/src/Plugins/Pdf/pdf_hummus_renderer.cpp
@@ -312,13 +312,7 @@ pdf_hummus_renderer_rep::pdf_hummus_renderer_rep (
   if (version == "1.7") ePDFVersion= ePDFVersion17;
   LogConfiguration log= LogConfiguration::DefaultLogConfiguration();
   PDFCreationSettings settings (true, true); //, EncryptionOptions("user", 4, "owner"));
-#if (defined (__MINGW__) || defined (__MINGW32__))
-    // WIN is using 8bit encodings, but pdfwriter expects UTF8
-    // if path or file contains non-ascii characters we need an extra conversion step. 
-    status = pdfWriter.StartPDF(as_charp(western_to_utf8(concretize (pdf_file_name))), ePDFVersion, log, settings);
-#else
     status = pdfWriter.StartPDF(as_charp(concretize (pdf_file_name)), ePDFVersion, log, settings);
-#endif  
 	if (status != PDFHummus::eSuccess) {
 		convert_error << "failed to start PDF\n";
 		started=false;
@@ -1202,13 +1196,7 @@ pdf_hummus_renderer_rep::make_pdf_font (string fontname)
     PDFUsedFont* font;
     {
       //debug_convert << "GetFontForFile "  << u  << LF;
-#if (defined (__MINGW__) || defined (__MINGW32__))
-    // WIN is using 8bit encodings, but pdfwriter expects UTF8
-    // if path or file contains non-ascii characters we need an extra conversion step. 
-      c_string _u (western_to_utf8(concretize (u)));
-#else
       c_string _u (concretize (u));
-#endif  
       font = pdfWriter.GetFontForFile((char*)_u);
       //tm_delete_array(_rname);
     }
@@ -1567,11 +1555,7 @@ pdf_image_rep::flush (PDFWriter& pdfw)
   EStatusCode status = PDFHummus::eFailure;
   DocumentContext& dc = pdfw.GetDocumentContext();
 
-#if (defined (__MINGW__) || defined (__MINGW32__))  
-  char* _temp= as_charp(western_to_utf8(concretize(temp)));
-#else
   char* _temp= as_charp(concretize(temp));
-#endif
   PDFDocumentCopyingContext *copyingContext = pdfw.CreatePDFCopyingContext(_temp);
   if(copyingContext) {
     PDFPageInput pageInput(copyingContext->GetSourceDocumentParser(),
@@ -1601,11 +1585,7 @@ void
 hummus_pdf_image_size (url image, int& w, int& h) {
   InputFile pdfFile;
   PDFParser* parser= new PDFParser();
-#if (defined (__MINGW__) || defined (__MINGW32__))
-  pdfFile.OpenFile(as_charp(western_to_utf8(concretize(image))));
-#else
   pdfFile.OpenFile(as_charp(concretize(image)));
-#endif
   EStatusCode status = parser->StartPDFParsing(pdfFile.GetInputStream());
   if (status != PDFHummus::eFailure) {
     PDFPageInput pageInput(parser, parser->ParsePage(0));
diff --git a/src/Plugins/Qt/QTMFileDialog.cpp b/src/Plugins/Qt/QTMFileDialog.cpp
index af36ef8..856d0be 100644
--- a/src/Plugins/Qt/QTMFileDialog.cpp
+++ b/src/Plugins/Qt/QTMFileDialog.cpp
@@ -122,7 +122,7 @@ BEGIN_SLOT
   xps->setText ("");
   yps->setText ("");
 
-  string localname = from_qstring_os8bits(file);
+  string localname = from_qstring_utf8(file);
   url image_url= url_system (localname);
   if (DEBUG_CONVERT) debug_convert<<"image preview :["<<image_url<<"]"<<LF;
   if (!(as_string(image_url)=="") && !is_directory(image_url) && exists(image_url) ){
@@ -147,7 +147,7 @@ BEGIN_SLOT
 	  }
 	  //generate thumbnail :
 	  image_to_png (image_url, temp, w, h);
-	  img.load (os8bits_to_qstring (as_string (temp)));
+	  img.load (utf8_to_qstring (as_string (temp)));
 	  remove (temp);
     }
   }
diff --git a/src/Plugins/Qt/qt_chooser_widget.cpp b/src/Plugins/Qt/qt_chooser_widget.cpp
index e9f41ec..cb244fd 100644
--- a/src/Plugins/Qt/qt_chooser_widget.cpp
+++ b/src/Plugins/Qt/qt_chooser_widget.cpp
@@ -206,7 +206,7 @@ void
 qt_chooser_widget_rep::perform_dialog () {
   QString caption = to_qstring (win_title);
   c_string tmp (directory * "/" * file);
-  QString path = QString::fromLocal8Bit (tmp);
+  QString path = QString::fromUtf8 (tmp);
   
 #if (defined(Q_WS_MAC) )// || defined(Q_WS_WIN)) //at least windows Xp and 7 lack image preview, switch to custom dialog
   QFileDialog* dialog = new QFileDialog (NULL, caption, path);
@@ -262,14 +262,9 @@ qt_chooser_widget_rep::perform_dialog () {
   if (dialog->exec ()) {
     fileNames = dialog->selectedFiles();
     if (fileNames.count() > 0) {
-      if (type != "image") {
-      string localname = from_qstring_os8bits(fileNames.first());
-      file = "(system->url " * scm_quote (localname) * ")";}
-      else {
       string imname    = from_qstring_utf8 (fileNames.first());
-      string localname = utf8_to_cork (imname);
-      // here we need the filename encoded cork-universal because it is exposed in the document, in the <image> tag
-      file = "(system->url " * scm_quote (localname) * ")";
+      file = "(system->url " * scm_quote (imname) * ")";
+      if (type == "image") {
 #if !defined(Q_WS_MAC) // && !defined(Q_WS_WIN)   //at least windows Xp and 7 lack image preview, switch to custom dialog
         file = "(list " * file * imgdialog->getParamsAsString () * ")"; //set image size from preview
 #else //MacOs only now
diff --git a/src/Plugins/Qt/qt_picture.cpp b/src/Plugins/Qt/qt_picture.cpp
index f53f565..6bf423f 100644
--- a/src/Plugins/Qt/qt_picture.cpp
+++ b/src/Plugins/Qt/qt_picture.cpp
@@ -157,11 +157,11 @@ QImage*
 get_image (url u, int w, int h) {
   QImage *pm = NULL;
   if (qt_supports (u))
-    pm= new QImage (os8bits_to_qstring (concretize (u)));
+    pm= new QImage (utf8_to_qstring (concretize (u)));
   else {
     url temp= url_temp (".png");
     image_to_png (u, temp, w, h);
-    pm= new QImage (os8bits_to_qstring (as_string (temp)));
+    pm= new QImage (utf8_to_qstring (as_string (temp)));
     remove (temp);
   }
   if (pm == NULL || pm->isNull ()) {
@@ -215,5 +215,5 @@ qt_apply_effect (tree eff, array<url> src, url dest, int w, int h) {
   picture t= e->apply (a, PIXEL);
   picture q= as_qt_picture (t);
   qt_picture_rep* pict= (qt_picture_rep*) q->get_handle ();
-  pict->pict.save (os8bits_to_qstring (concretize (dest)));
+  pict->pict.save (utf8_to_qstring (concretize (dest)));
 }
diff --git a/src/Plugins/Qt/qt_sys_utils.cpp b/src/Plugins/Qt/qt_sys_utils.cpp
index a2c544f..08a0e64 100644
--- a/src/Plugins/Qt/qt_sys_utils.cpp
+++ b/src/Plugins/Qt/qt_sys_utils.cpp
@@ -31,7 +31,7 @@ static int
 qt_system (QProcess& proc, string& cmd, string& cmdout, string& cmderr) {
   c_string _cmd (cmd);
 #ifdef OS_MINGW
-  QString qcmd = QString::fromLocal8Bit (_cmd);
+  QString qcmd = QString::fromUtf8 (_cmd);
 #else
   QString qcmd = "sh -c \"";
   qcmd += _cmd;
diff --git a/src/Plugins/Qt/qt_utilities.cpp b/src/Plugins/Qt/qt_utilities.cpp
index a89b720..cd2cbc2 100644
--- a/src/Plugins/Qt/qt_utilities.cpp
+++ b/src/Plugins/Qt/qt_utilities.cpp
@@ -318,31 +318,6 @@ from_qstring_utf8 (const QString &s) {
   return string ((char*) cstr);
 }
 
-// os8bits == UTF-8 on linux/Mac OS but ==locale codepage on windows
-// Qt offers no way to explicitly know what is the encoding used!
-// note that older Unix/linuxes did not use UTF-8
-QString
-os8bits_to_qstring (const string& s) {
-  c_string p (s);
-  QString nss= QString::fromLocal8Bit (p, N(s));
-  return nss;
-}
-
-string
-from_qstring_os8bits (const QString &s) {
-  QByteArray arr= s.toLocal8Bit ();
-  const char* cstr= arr.constData ();
-  return string ((char*) cstr);
-}
-
-string
-cork_to_os8bits (const string s){   
-  // Note: this function is declared in converter.hpp 
-  // (and implemented in converter.cpp for X11)
-  // In Qt version we stick to Qt routines for consistency
-  return from_qstring_os8bits(utf8_to_qstring (cork_to_utf8 (s)));
-}
-
 // This should provide better lookup times
 static QHash<QString, QColor> _NamedColors;
 
@@ -412,7 +387,7 @@ qt_supports (url u) {
 bool
 qt_image_size (url image, int& w, int& h) {// w, h in points
   if (DEBUG_CONVERT) debug_convert << "qt_image_size :" <<LF;
-  QImage im= QImage (os8bits_to_qstring (concretize (image)));
+  QImage im= QImage (utf8_to_qstring (concretize (image)));
   if (im.isNull ()) {
       convert_error << "Cannot read image file '" << image << "'"
       << " in qt_image_size" << LF;
@@ -431,14 +406,14 @@ qt_image_size (url image, int& w, int& h) {// w, h in points
 void
 qt_convert_image (url image, url dest, int w, int h) {// w, h in pixels
   if (DEBUG_CONVERT) debug_convert << "qt_convert_image " << image << " -> "<<dest<<LF;
-  QImage im (os8bits_to_qstring (concretize (image)));
+  QImage im (utf8_to_qstring (concretize (image)));
   if (im.isNull ())
     convert_error << "Cannot read image file '" << image << "'"
     << " in qt_convert_image" << LF;
   else {
     if (w > 0 && h > 0)
       im= im.scaled (w, h, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
-    im.scaled (w, h).save (os8bits_to_qstring (concretize (dest)));
+    im.scaled (w, h).save (utf8_to_qstring (concretize (dest)));
   }
 }
 
@@ -463,8 +438,8 @@ qt_image_to_pdf (url image, url outfile, int w_pt, int h_pt, int dpi) {
   printer.setFullPage(true);
   if (!dpi) dpi=96; 
   printer.setResolution(dpi);
-  printer.setOutputFileName(os8bits_to_qstring (concretize (outfile)));
-  QImage im (os8bits_to_qstring (concretize (image)));
+  printer.setOutputFileName(utf8_to_qstring (concretize (outfile)));
+  QImage im (utf8_to_qstring (concretize (image)));
   if (im.isNull ()) {
     convert_error << "Cannot read image file '" << image << "'"
     << " in qt_image_to_pdf" << LF;
@@ -716,6 +691,9 @@ qt_translate (const string& s) {
 string
 qt_application_directory () {
   return string (QCoreApplication::applicationDirPath().toLatin1().constData());
+  // This is used to set $TEXMACS_PATH
+  // in Windows TeXmacs cannot run if this path contains unicode characters
+  // apparently because Guile uses standard narrow char api to load its modules => patch Guile?.  
   // return from_qstring (QCoreApplication::applicationDirPath ());
 }
 
diff --git a/src/Plugins/Qt/qt_utilities.hpp b/src/Plugins/Qt/qt_utilities.hpp
index 3bacc95..b388ccb 100644
--- a/src/Plugins/Qt/qt_utilities.hpp
+++ b/src/Plugins/Qt/qt_utilities.hpp
@@ -66,8 +66,6 @@ string       from_qstring (const QString & s);
 QString   utf8_to_qstring (const string& s);
 QString latin1_to_qstring (const string& s);
 string  from_qstring_utf8 (const QString & s);
-QString os8bits_to_qstring (const string& s);
-string from_qstring_os8bits (const QString &s);
 
 /*! Returns a QString with the translation of the argument to the current
  language.
diff --git a/src/Plugins/Windows/iostream.cpp b/src/Plugins/Windows/iostream.cpp
new file mode 100755
index 0000000..e3874ac
--- /dev/null
+++ b/src/Plugins/Windows/iostream.cpp
@@ -0,0 +1,263 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#define NOWIDE_SOURCE
+#include <nowide/iostream.hpp>
+#include <nowide/convert.hpp>
+#include <stdio.h>
+#include <vector>
+
+#ifdef NOWIDE_WINDOWS
+
+#ifndef NOMINMAX
+# define NOMINMAX
+#endif
+
+
+#include <windows.h>
+
+
+namespace nowide {
+namespace details {
+
+	namespace {
+		bool is_atty_handle(HANDLE h) 
+		{
+            if(h) {
+                DWORD dummy;
+                return GetConsoleMode(h,&dummy) == TRUE;
+            }
+			return false;
+		}
+	}
+
+    class console_output_buffer : public std::streambuf {
+    public:
+        console_output_buffer(HANDLE h) :
+            handle_(h)
+        {
+        }
+    protected:
+        int sync()
+        {
+            return overflow(EOF);
+        }
+        int overflow(int c)
+        {
+            if(!handle_)
+                return -1;
+            int n = pptr() - pbase();
+            int r = 0;
+            
+            if(n > 0 && (r=write(pbase(),n)) < 0)
+                    return -1;
+            if(r < n) {
+                memmove(pbase(),pbase() + r,n-r);
+            }
+            setp(buffer_, buffer_ + buffer_size);
+            pbump(n-r);
+            if(c!=EOF)
+                sputc(c);
+            return 0;
+        }
+    private:
+        
+        int write(char const *p,int n)
+        {
+            namespace uf = nowide::utf;
+            char const *b = p;
+            char const *e = p+n;
+            DWORD size=0;
+            if(n > buffer_size)
+                return -1;
+            wchar_t *out = wbuffer_;
+            uf::code_point c;
+            size_t decoded = 0;
+            while(p < e && (c = uf::utf_traits<char>::decode(p,e))!=uf::illegal && c!=uf::incomplete) {
+                out = uf::utf_traits<wchar_t>::encode(c,out);
+                decoded = p-b;
+            }
+            if(c==uf::illegal)
+                return -1;
+            if(!WriteConsoleW(handle_,wbuffer_,out - wbuffer_,&size,0))
+                return -1;
+            return decoded;
+        }
+        
+        static const int buffer_size = 1024;
+        char buffer_[buffer_size];
+        wchar_t wbuffer_[buffer_size]; // for null
+        HANDLE handle_;
+    };
+    
+    class console_input_buffer: public std::streambuf {
+    public:
+        console_input_buffer(HANDLE h) :
+            handle_(h),
+            wsize_(0)
+        {
+        } 
+        
+    protected:
+        int pbackfail(int c)
+        {
+            if(c==EOF)
+                return EOF;
+            
+            if(gptr()!=eback()) {
+                gbump(-1);
+                *gptr() = c;
+                return 0;
+            }
+            
+            if(pback_buffer_.empty()) {
+                pback_buffer_.resize(4);
+                char *b = &pback_buffer_[0];
+                char *e = b + pback_buffer_.size();
+                setg(b,e-1,e);
+                *gptr() = c;
+            }
+            else {
+                size_t n = pback_buffer_.size();
+                std::vector<char> tmp;
+                tmp.resize(n*2);
+                memcpy(&tmp[n],&pback_buffer_[0],n);
+                tmp.swap(pback_buffer_);
+                char *b = &pback_buffer_[0];
+                char *e = b + n * 2;
+                char *p = b+n-1;
+                *p = c;
+                setg(b,p,e);
+            }
+          
+            return 0;
+        }
+
+        int underflow()
+        {
+            if(!handle_)
+                return -1;
+            if(!pback_buffer_.empty())
+                pback_buffer_.clear();
+            
+            size_t n = read();
+            setg(buffer_,buffer_,buffer_+n);
+            if(n == 0)
+                return EOF;
+            return std::char_traits<char>::to_int_type(*gptr());
+        }
+        
+    private:
+        
+        size_t read()
+        {
+            namespace uf = nowide::utf;
+            DWORD read_wchars = 0;
+            size_t n = wbuffer_size - wsize_;
+            if(!ReadConsoleW(handle_,wbuffer_,n,&read_wchars,0))
+                return 0;
+            wsize_ += read_wchars;
+            char *out = buffer_;
+            wchar_t *b = wbuffer_;
+            wchar_t *e = b + wsize_;
+            wchar_t *p = b;
+            uf::code_point c;
+            wsize_ = e-p;
+            while(p < e && (c = uf::utf_traits<wchar_t>::decode(p,e))!=uf::illegal && c!=uf::incomplete) {
+                out = uf::utf_traits<char>::encode(c,out);
+                wsize_ = e-p;
+            }
+            
+            if(c==uf::illegal)
+                return 0;
+            
+            
+            if(c==uf::incomplete) {
+                memmove(b,e-wsize_,sizeof(wchar_t)*wsize_);
+            }
+            
+            return out - buffer_;
+        }
+        
+        static const size_t buffer_size = 1024 * 3;
+        static const size_t wbuffer_size = 1024;
+        char buffer_[buffer_size];
+        wchar_t wbuffer_[buffer_size]; // for null
+        HANDLE handle_;
+        int wsize_;
+        std::vector<char> pback_buffer_;
+    };
+
+    winconsole_ostream::winconsole_ostream(int fd) : std::ostream(0)
+    {
+        HANDLE h = 0;
+        switch(fd) {
+        case 1:
+            h = GetStdHandle(STD_OUTPUT_HANDLE);
+            break;
+        case 2:
+            h = GetStdHandle(STD_ERROR_HANDLE);
+            break;
+        }
+		if(is_atty_handle(h)) {
+			d.reset(new console_output_buffer(h));
+			std::ostream::rdbuf(d.get());
+		}
+		else {
+			std::ostream::rdbuf( fd == 1 ? std::cout.rdbuf() : std::cerr.rdbuf() );
+		}
+    }
+    winconsole_ostream::~winconsole_ostream()
+    {
+		try {
+			flush();
+		}
+		catch(...){}
+    }
+
+    winconsole_istream::winconsole_istream() : std::istream(0)
+    {
+        HANDLE h = GetStdHandle(STD_INPUT_HANDLE);
+		if(is_atty_handle(h)) {
+			d.reset(new console_input_buffer(h));
+			std::istream::rdbuf(d.get());
+		}
+		else {
+			std::istream::rdbuf(std::cin.rdbuf());
+		}
+    }
+    
+    winconsole_istream::~winconsole_istream()
+    {
+    }
+    
+} // details
+    
+NOWIDE_DECL details::winconsole_istream cin;
+NOWIDE_DECL details::winconsole_ostream cout(1);
+NOWIDE_DECL details::winconsole_ostream cerr(2);
+NOWIDE_DECL details::winconsole_ostream clog(2);
+    
+namespace {
+    struct initialize {
+        initialize()
+        {
+            nowide::cin.tie(&nowide::cout);
+            nowide::cerr.tie(&nowide::cout);
+            nowide::clog.tie(&nowide::cout);
+        }
+    } inst;
+}
+
+
+    
+} // nowide
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/args.hpp b/src/Plugins/Windows/nowide/args.hpp
new file mode 100755
index 0000000..d1e9b44
--- /dev/null
+++ b/src/Plugins/Windows/nowide/args.hpp
@@ -0,0 +1,167 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_ARGS_HPP_INCLUDED
+#define NOWIDE_ARGS_HPP_INCLUDED
+
+#include <nowide/config.hpp>
+#include <nowide/stackstring.hpp>
+#include <vector>
+#ifdef NOWIDE_WINDOWS
+#include <nowide/windows.hpp>
+#endif
+
+
+namespace nowide {
+    #if !defined(NOWIDE_WINDOWS) && !defined(NOWIDE_DOXYGEN)
+    class args {
+    public:
+        args(int &,char **&) {}
+        args(int &,char **&,char **&){}
+        ~args() {}
+    };
+
+    #else
+
+    ///
+    /// \brief args is a class that fixes standard main() function arguments and changes them to UTF-8 under 
+    /// Microsoft Windows.
+    ///
+    /// The class uses \c GetCommandLineW(), \c CommandLineToArgvW() and \c GetEnvironmentStringsW()
+    /// in order to obtain the information. It does not relates to actual values of argc,argv and env
+    /// under Windows.
+    ///
+    /// It restores the original values in its destructor
+    ///
+    /// \note the class owns the memory of the newly allocated strings
+    ///
+    class args {
+    public:
+        
+        ///
+        /// Fix command line agruments 
+        ///
+        args(int &argc,char **&argv) :
+            old_argc_(argc),
+            old_argv_(argv),
+            old_env_(0),
+            old_argc_ptr_(&argc),
+            old_argv_ptr_(&argv),
+            old_env_ptr_(0)
+        {
+            fix_args(argc,argv);
+        }
+        ///
+        /// Fix command line agruments and environment
+        ///
+        args(int &argc,char **&argv,char **&en) :
+            old_argc_(argc),
+            old_argv_(argv),
+            old_env_(en),
+            old_argc_ptr_(&argc),
+            old_argv_ptr_(&argv),
+            old_env_ptr_(&en)
+        {
+            fix_args(argc,argv);
+            fix_env(en);
+        }
+        ///
+        /// Restore original argc,argv,env values, if changed
+        ///
+        ~args()
+        {
+            if(old_argc_ptr_)
+                *old_argc_ptr_ = old_argc_;
+            if(old_argv_ptr_)
+                *old_argv_ptr_ = old_argv_;
+            if(old_env_ptr_) 
+                *old_env_ptr_ = old_env_;
+        }
+    private:    
+        void fix_args(int &argc,char **&argv)
+        {
+                int wargc;
+                wchar_t **wargv = CommandLineToArgvW(GetCommandLineW(),&wargc);
+            if(!wargv) {
+                argc = 0;
+                static char *dummy = 0;
+                argv = &dummy;
+                return;
+            }
+            try{ 
+                args_.resize(wargc+1,0);
+                arg_values_.resize(wargc);
+                for(int i=0;i<wargc;i++) {
+                    if(!arg_values_[i].convert(wargv[i])) {
+                        wargc = i;
+                        break;
+                    }
+                    args_[i] = arg_values_[i].c_str();
+                }
+                argc = wargc;
+                argv = &args_[0];
+            }
+            catch(...) {
+                LocalFree(wargv);
+                throw;
+            }
+            LocalFree(wargv);
+        }
+        void fix_env(char **&en)
+        {
+            static char *dummy = 0;
+            en = &dummy;
+            wchar_t *wstrings = GetEnvironmentStringsW();
+            if(!wstrings)
+                return;
+            try {
+                wchar_t *wstrings_end = 0;
+                int count = 0;
+                for(wstrings_end = wstrings;*wstrings_end;wstrings_end+=wcslen(wstrings_end)+1)
+                        count++;
+                if(env_.convert(wstrings,wstrings_end)) {
+                    envp_.resize(count+1,0);
+                    char *p=env_.c_str();
+                    int pos = 0;
+                    for(int i=0;i<count;i++) {
+                        if(*p!='=')
+                            envp_[pos++] = p;
+                        p+=strlen(p)+1;
+                    }
+                    en = &envp_[0];
+                }
+            }
+            catch(...) {
+                FreeEnvironmentStringsW(wstrings);
+                throw;
+            }
+            FreeEnvironmentStringsW(wstrings);
+
+        }
+
+        std::vector<char *> args_;
+        std::vector<short_stackstring> arg_values_;
+        stackstring env_;
+        std::vector<char *> envp_;
+
+        int old_argc_;
+        char **old_argv_;
+        char **old_env_;
+
+        int  *old_argc_ptr_;
+        char ***old_argv_ptr_;
+        char ***old_env_ptr_;
+    };
+
+    #endif
+
+} // nowide
+
+#endif
+
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/cenv.hpp b/src/Plugins/Windows/nowide/cenv.hpp
new file mode 100755
index 0000000..a6351cd
--- /dev/null
+++ b/src/Plugins/Windows/nowide/cenv.hpp
@@ -0,0 +1,139 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_CENV_H_INCLUDED
+#define NOWIDE_CENV_H_INCLUDED
+
+#include <string>
+#include <stdexcept>
+#include <stdlib.h>
+#include <nowide/config.hpp>
+#include <nowide/stackstring.hpp>
+#include <vector>
+
+#ifdef NOWIDE_WINDOWS
+#include <nowide/windows.hpp>
+#endif
+
+
+namespace nowide {
+    #if !defined(NOWIDE_WINDOWS) && !defined(NOWIDE_DOXYGEN)
+    using ::getenv;
+    using ::setenv;
+    using ::unsetenv;
+    using ::putenv;
+    #else
+    ///
+    /// \brief UTF-8 aware getenv. Returns 0 if the variable is not set.
+    ///
+    /// This function is not thread safe or reenterable as defined by the standard library
+    ///
+    inline char *getenv(char const *key)
+    {
+        static stackstring value;
+        
+        wshort_stackstring name;
+        if(!name.convert(key))
+            return 0;
+
+        static const size_t buf_size = 64;
+        wchar_t buf[buf_size];
+        std::vector<wchar_t> tmp;
+        wchar_t *ptr = buf;
+        size_t n = GetEnvironmentVariableW(name.c_str(),buf,buf_size);
+        if(n == 0 && GetLastError() == 203) // ERROR_ENVVAR_NOT_FOUND
+            return 0;
+        if(n >= buf_size) {
+            tmp.resize(n+1,L'\0');
+            n = GetEnvironmentVariableW(name.c_str(),&tmp[0],static_cast<unsigned>(tmp.size() - 1));
+            // The size may have changed
+            if(n >= tmp.size() - 1)
+                return 0;
+            ptr = &tmp[0];
+        }
+        if(!value.convert(ptr))
+            return 0;
+        return value.c_str();
+    }
+    ///
+    /// \brief  UTF-8 aware setenv, \a key - the variable name, \a value is a new UTF-8 value,
+    /// 
+    /// if override is not 0, that the old value is always overridded, otherwise,
+    /// if the variable exists it remains unchanged
+    ///
+    inline int setenv(char const *key,char const *value,int override)
+    {
+        wshort_stackstring name;
+        if(!name.convert(key))
+            return -1;
+        if(!override) {
+            wchar_t unused[2];
+            if(!(GetEnvironmentVariableW(name.c_str(),unused,2)==0 && GetLastError() == 203)) // ERROR_ENVVAR_NOT_FOUND
+                return 0;
+        }
+        wstackstring wval;
+        if(!wval.convert(value))
+            return -1;
+// TeXmacs specific 2017: if Guile is not compiled with nowide we need to set the env variables with (w)putenv too 
+        char * s =  (char*) malloc(strlen(key) + strlen(value) + 2);
+        strcpy(s, key);
+        strcat(s, "=");
+        strcat(s, value);
+        wstackstring ws;
+        ws.convert(s);
+        _wputenv(ws.c_str());
+//end Texmacs specific
+        if(SetEnvironmentVariableW(name.c_str(),wval.c_str()))
+            return 0;
+        return -1;
+    }
+    ///
+    /// \brief Remove enviroment variable \a key
+    ///
+    inline int unsetenv(char const *key)
+    {
+        wshort_stackstring name;
+        if(!name.convert(key))
+            return -1;
+        if(SetEnvironmentVariableW(name.c_str(),0))
+            return 0;
+        return -1;
+    }
+    ///
+    /// \brief UTF-8 aware putenv implementation, expects string in format KEY=VALUE
+    ///
+    inline int putenv(char *string)
+    {
+        char const *key = string;
+        char const *key_end = string;
+        while(*key_end!='=' && *key_end!='\0')
+            key_end++;
+        if(*key_end == '\0')
+            return -1;
+        wshort_stackstring wkey;
+        if(!wkey.convert(key,key_end))
+            return -1;
+        
+        wstackstring wvalue;
+        if(!wvalue.convert(key_end+1))
+            return -1;
+// TeXmacs specific 2017: if Guile is not compiled with nowide we need to set the env variables with (w)putenv too 
+        wstackstring wstring;
+        wstring.convert(string);
+        _wputenv(wstring.c_str());
+//end Texmacs specific
+        if(SetEnvironmentVariableW(wkey.c_str(),wvalue.c_str()))
+            return 0;
+        return -1;
+    }
+    #endif
+} // nowide
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/config.hpp b/src/Plugins/Windows/nowide/config.hpp
new file mode 100644
index 0000000..89c1f51
--- /dev/null
+++ b/src/Plugins/Windows/nowide/config.hpp
@@ -0,0 +1,37 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_CONFIG_H_INCLUDED
+#define NOWIDE_CONFIG_H_INCLUDED
+
+
+#if (defined(__WIN32) || defined(_WIN32) || defined(WIN32)) && !defined(__CYGWIN__)
+#define NOWIDE_WINDOWS
+#endif
+
+#ifdef _MSC_VER
+#define NOWIDE_MSVC
+#endif
+
+#ifdef NOWIDE_WINDOWS
+#   if defined(DLL_EXPORT) || defined(NOWIDE_EXPORT)
+#       ifdef NOWIDE_SOURCE
+#           define NOWIDE_DECL __declspec(dllexport)
+#       else
+#           define NOWIDE_DECL __declspec(dllimport)
+#       endif  //NOWIDE_SOURCE
+#   endif  // DYN_LINK
+#endif  
+
+#ifndef NOWIDE_DECL
+#   define NOWIDE_DECL
+#endif
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/convert.hpp b/src/Plugins/Windows/nowide/convert.hpp
new file mode 100755
index 0000000..39cd158
--- /dev/null
+++ b/src/Plugins/Windows/nowide/convert.hpp
@@ -0,0 +1,154 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_CONVERT_H_INCLUDED
+#define NOWIDE_CONVERT_H_INCLUDED
+
+#include <string>
+#include <nowide/encoding_utf.hpp>
+
+
+namespace nowide {
+    ///
+    /// \brief Template function that converts a buffer of UTF sequences in range [source_begin,source_end)
+    /// to the output \a buffer of size \a buffer_size.
+    ///
+    /// In case of success a NULL terminated string is returned (buffer), otherwise 0 is returned.
+    ///
+    /// If there is not enough room in the buffer or the source sequence contains invalid UTF,
+    /// 0 is returned, and the contents of the buffer are undefined.
+    ///
+    template<typename CharOut,typename CharIn>
+    CharOut *basic_convert(CharOut *buffer,size_t buffer_size,CharIn const *source_begin,CharIn const *source_end)
+    {
+        CharOut *rv = buffer;
+        if(buffer_size == 0)
+            return 0;
+        buffer_size --;
+        while(source_begin!=source_end) {
+            using namespace nowide::utf;
+            code_point c = utf_traits<CharIn>::template decode<CharIn const *>(source_begin,source_end);
+            if(c==illegal || c==incomplete) {
+                rv = 0;
+                break;
+            }
+            size_t width = utf_traits<CharOut>::width(c);
+            if(buffer_size < width) {
+                rv=0;
+                break;
+            }
+            buffer = utf_traits<CharOut>::template encode<CharOut *>(c,buffer);
+            buffer_size -= width;
+        }
+        *buffer++ = 0;
+        return rv;
+    }
+
+    /// \cond INTERNAL
+    namespace details {
+        //
+        // wcslen defined only in C99... So we will not use it
+        //
+        template<typename Char>
+        Char const *basic_strend(Char const *s)
+        {
+            while(*s)
+                s++;
+            return s;
+        }
+    }
+    /// \endcond
+
+    ///
+    /// Convert NULL terminated UTF source string to NULL terminated \a output string of size at
+    /// most output_size (including NULL)
+    /// 
+    /// In case of success output is returned, if the input sequence is illegal,
+    /// or there is not enough room NULL is returned 
+    ///
+    inline char *narrow(char *output,size_t output_size,wchar_t const *source)
+    {
+        return basic_convert(output,output_size,source,details::basic_strend(source));
+    }
+    ///
+    /// Convert UTF text in range [begin,end) to NULL terminated \a output string of size at
+    /// most output_size (including NULL)
+    /// 
+    /// In case of success output is returned, if the input sequence is illegal,
+    /// or there is not enough room NULL is returned 
+    ///
+    inline char *narrow(char *output,size_t output_size,wchar_t const *begin,wchar_t const *end)
+    {
+        return basic_convert(output,output_size,begin,end);
+    }
+    ///
+    /// Convert NULL terminated UTF source string to NULL terminated \a output string of size at
+    /// most output_size (including NULL)
+    /// 
+    /// In case of success output is returned, if the input sequence is illegal,
+    /// or there is not enough room NULL is returned 
+    ///
+    inline wchar_t *widen(wchar_t *output,size_t output_size,char const *source)
+    {
+        return basic_convert(output,output_size,source,details::basic_strend(source));
+    }
+    ///
+    /// Convert UTF text in range [begin,end) to NULL terminated \a output string of size at
+    /// most output_size (including NULL)
+    /// 
+    /// In case of success output is returned, if the input sequence is illegal,
+    /// or there is not enough room NULL is returned 
+    ///
+    inline wchar_t *widen(wchar_t *output,size_t output_size,char const *begin,char const *end)
+    {
+        return basic_convert(output,output_size,begin,end);
+    }
+
+
+    ///
+    /// Convert between Wide - UTF-16/32 string and UTF-8 string.
+    ///
+    /// nowide::conv::conversion_error is thrown in a case of a error
+    ///
+    inline std::string narrow(wchar_t const *s)
+    {
+        return nowide::conv::utf_to_utf<char>(s);
+    }
+    ///
+    /// Convert between UTF-8 and UTF-16 string, implemented only on Windows platform
+    ///
+    /// nowide::conv::conversion_error is thrown in a case of a error
+    ///
+    inline std::wstring widen(char const *s)
+    {
+        return nowide::conv::utf_to_utf<wchar_t>(s);
+    }
+    ///
+    /// Convert between Wide - UTF-16/32 string and UTF-8 string
+    ///
+    /// nowide::conv::conversion_error is thrown in a case of a error
+    ///
+    inline std::string narrow(std::wstring const &s) 
+    {
+        return nowide::conv::utf_to_utf<char>(s);
+    }
+    ///
+    /// Convert between UTF-8 and UTF-16 string, implemented only on Windows platform
+    ///
+    /// nowide::conv::conversion_error is thrown in a case of a error
+    ///
+    inline std::wstring widen(std::string const &s) 
+    {
+        return nowide::conv::utf_to_utf<wchar_t>(s);
+    }
+
+} // nowide
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/cstdio.hpp b/src/Plugins/Windows/nowide/cstdio.hpp
new file mode 100755
index 0000000..9115e86
--- /dev/null
+++ b/src/Plugins/Windows/nowide/cstdio.hpp
@@ -0,0 +1,176 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_CSTDIO_H_INCLUDED
+#define NOWIDE_CSTDIO_H_INCLUDED
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+
+#include <cstdio>
+#include <stdio.h>
+#include <nowide/config.hpp>
+#include <nowide/convert.hpp>
+#include <nowide/stackstring.hpp>
+#include <errno.h>
+
+#ifdef NOWIDE_MSVC
+#  pragma warning(push)
+#  pragma warning(disable : 4996)
+#endif
+
+
+
+namespace nowide {
+#if !defined(NOWIDE_WINDOWS) && !defined(NOWIDE_DOXYGEN)
+    using std::fopen;
+    using std::freopen;
+    using std::remove;
+    using std::rename;
+#else
+
+///
+/// \brief Same as freopen but file_name and mode are UTF-8 strings
+///
+/// If invalid UTF-8 given, NULL is returned and errno is set to EINVAL
+///
+inline FILE *freopen(char const *file_name,char const *mode,FILE *stream)
+{
+    wstackstring wname;
+    wshort_stackstring wmode;
+    if(!wname.convert(file_name) || !wmode.convert(mode)) {
+        errno = EINVAL;
+        return 0;
+    }
+    return _wfreopen(wname.c_str(),wmode.c_str(),stream);
+}
+///
+/// \brief Same as fopen but file_name and mode are UTF-8 strings
+///
+/// If invalid UTF-8 given, NULL is returned and errno is set to EINVAL
+///
+inline FILE *fopen(char const *file_name,char const *mode)
+{
+    wstackstring wname;
+    wshort_stackstring wmode;
+    if(!wname.convert(file_name) || !wmode.convert(mode)) {
+        errno = EINVAL;
+        return 0;
+    }
+    return _wfopen(wname.c_str(),wmode.c_str());
+}
+///
+/// \brief Same as rename but old_name and new_name are UTF-8 strings
+///
+/// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
+///
+inline int rename(char const *old_name,char const *new_name)
+{
+    wstackstring wold,wnew;
+    if(!wold.convert(old_name) || !wnew.convert(new_name)) {
+        errno = EINVAL;
+        return -1;
+    }
+    return _wrename(wold.c_str(),wnew.c_str());
+}
+///
+/// \brief Same as remove but name is UTF-8 string
+///
+/// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
+///
+inline int remove(char const *name)
+{
+    wstackstring wname;
+    if(!wname.convert(name)) {
+        errno = EINVAL;
+        return -1;
+    }
+    int retval;
+    retval = _wremove(wname.c_str());
+    return (retval == -1)? _wrmdir (wname.c_str()) : retval;
+}
+///
+/// \brief Same as chmod but file_name and mode are UTF-8 strings
+///
+/// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
+///
+inline int chmod(char const *name, int const mode)
+{
+    wstackstring wname;
+    if(!wname.convert(name) ) {
+        errno = EINVAL;
+        return -1;
+    }
+    return _wchmod (wname.c_str(), mode);
+}
+	
+///
+/// \brief Same as mkdir but file_name and mode are UTF-8 strings
+///
+/// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
+///
+inline int mkdir(char const *name, int const mode)
+{
+    wstackstring wname;
+    if(!wname.convert(name) ) {
+        errno = EINVAL;
+        return -1;
+    }
+    return _wmkdir (wname.c_str());
+}
+#include <sys/stat.h>
+inline int stat(char const *name, struct_stat *buf)
+{
+    wstackstring wname;
+    if(!wname.convert(name)) {
+        errno = EINVAL;
+        return -1;
+    }
+    return _wstat32(wname.c_str(), buf);
+}
+typedef _WDIR DIR;
+inline DIR* opendir(char const *name)
+{
+    wstackstring wname;
+    if(!wname.convert(name) ) {
+        errno = EINVAL;
+        return NULL;
+    }
+    return _wopendir (wname.c_str());
+}
+
+inline char* readir_entry(DIR* dir)
+{
+  struct _wdirent *wentry;
+  wentry = _wreaddir (dir);
+  while (wentry 
+	     && (0 == wcscmp (wentry->d_name, L".") ||
+		 0 == wcscmp (wentry->d_name, L"..")))
+	     wentry = _wreaddir (dir);
+  if (wentry == NULL) return NULL;
+  else { 
+  stackstring entry;
+    if(!entry.convert(wentry->d_name) ) {
+        errno = EINVAL;
+        return NULL;
+    }
+    else return entry.c_str();
+  }
+} 
+
+#endif
+} // nowide
+
+
+#ifdef NOWIDE_MSVC
+#pragma warning(pop)
+#endif
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/cstdlib.hpp b/src/Plugins/Windows/nowide/cstdlib.hpp
new file mode 100755
index 0000000..0a7cf69
--- /dev/null
+++ b/src/Plugins/Windows/nowide/cstdlib.hpp
@@ -0,0 +1,16 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_CSTDLIB_HPP_INCLUDED
+#define NOWIDE_CSTDLIB_HPP_INCLUDED
+
+#include <nowide/cenv.hpp>
+#include <nowide/system.hpp>
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/encoding_errors.hpp b/src/Plugins/Windows/nowide/encoding_errors.hpp
new file mode 100755
index 0000000..a7a4058
--- /dev/null
+++ b/src/Plugins/Windows/nowide/encoding_errors.hpp
@@ -0,0 +1,58 @@
+//
+//  Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_ENCODING_ERRORS_HPP_INCLUDED
+#define NOWIDE_ENCODING_ERRORS_HPP_INCLUDED
+
+#include <nowide/config.hpp>
+#ifdef NOWIDE_MSVC
+#  pragma warning(push)
+#  pragma warning(disable : 4275 4251 4231 4660)
+#endif
+#include <stdexcept>
+
+
+
+namespace nowide {
+    namespace conv {
+        ///
+        /// \addtogroup codepage 
+        ///
+        /// @{
+
+        ///
+        /// \brief The excepton that is thrown in case of conversion error
+        ///
+        class conversion_error : public std::runtime_error {
+        public:
+            conversion_error() : std::runtime_error("Conversion failed") {}
+        };
+
+        ///
+        /// enum that defines conversion policy
+        ///
+        typedef enum {
+            skip            = 0,    ///< Skip illegal/unconvertable characters
+            stop            = 1,    ///< Stop conversion and throw conversion_error
+            default_method  = skip  ///< Default method - skip
+        } method_type;
+
+
+        /// @}
+
+    } // conv
+
+} // nowide
+
+#ifdef NOWIDE_MSVC
+#pragma warning(pop)
+#endif
+
+#endif
+
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
+
diff --git a/src/Plugins/Windows/nowide/encoding_utf.hpp b/src/Plugins/Windows/nowide/encoding_utf.hpp
new file mode 100755
index 0000000..439c126
--- /dev/null
+++ b/src/Plugins/Windows/nowide/encoding_utf.hpp
@@ -0,0 +1,84 @@
+//
+//  Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_ENCODING_UTF_HPP_INCLUDED
+#define NOWIDE_ENCODING_UTF_HPP_INCLUDED
+
+#include <nowide/utf.hpp>
+#include <nowide/encoding_errors.hpp>
+#include <string>
+#include <iterator>
+#ifdef NOWIDE_MSVC
+#  pragma warning(push)
+#  pragma warning(disable : 4275 4251 4231 4660)
+#endif
+
+
+namespace nowide{
+    namespace conv {
+        ///
+        /// Convert a Unicode text in range [begin,end) to other Unicode encoding
+        ///
+        template<typename CharOut,typename CharIn>
+        std::basic_string<CharOut>
+        utf_to_utf(CharIn const *begin,CharIn const *end,method_type how = default_method)
+        {
+            std::basic_string<CharOut> result;
+            result.reserve(end-begin);
+            typedef std::back_insert_iterator<std::basic_string<CharOut> > inserter_type;
+            inserter_type inserter(result);
+            utf::code_point c;
+            while(begin!=end) {
+                c=utf::utf_traits<CharIn>::template decode<CharIn const *>(begin,end);
+                if(c==utf::illegal || c==utf::incomplete) {
+                    if(how==stop)
+                        throw conversion_error();
+                }
+                else {
+                    utf::utf_traits<CharOut>::template encode<inserter_type>(c,inserter);
+                }
+            }
+            return result;
+        }
+
+        ///
+        /// Convert a Unicode NULL terminated string \a str other Unicode encoding
+        ///
+        template<typename CharOut,typename CharIn>
+        std::basic_string<CharOut>
+        utf_to_utf(CharIn const *str,method_type how = default_method)
+        {
+            CharIn const *end = str;
+            while(*end)
+                end++;
+            return utf_to_utf<CharOut,CharIn>(str,end,how);
+        }
+
+
+        ///
+        /// Convert a Unicode string \a str other Unicode encoding
+        ///
+        template<typename CharOut,typename CharIn>
+        std::basic_string<CharOut>
+        utf_to_utf(std::basic_string<CharIn> const &str,method_type how = default_method)
+        {
+            return utf_to_utf<CharOut,CharIn>(str.c_str(),str.c_str()+str.size(),how);
+        }
+
+
+
+} // conv
+} // nowide
+
+#ifdef NOWIDE_MSVC
+#pragma warning(pop)
+#endif
+
+#endif
+
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
+
diff --git a/src/Plugins/Windows/nowide/filebuf.hpp b/src/Plugins/Windows/nowide/filebuf.hpp
new file mode 100755
index 0000000..1ea9adc
--- /dev/null
+++ b/src/Plugins/Windows/nowide/filebuf.hpp
@@ -0,0 +1,415 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_FILEBUF_HPP
+#define NOWIDE_FILEBUF_HPP
+
+#include <iosfwd>
+#include <nowide/config.hpp>
+#include <nowide/stackstring.hpp>
+#include <fstream>
+#include <streambuf>
+#include <stdio.h>
+
+#ifdef NOWIDE_MSVC
+#  pragma warning(push)
+#  pragma warning(disable : 4996 4244 4800)
+#endif
+
+
+
+namespace nowide {
+#if !defined(NOWIDE_WINDOWS) && !defined(NOWIDE_FSTREAM_TESTS) && !defined(NOWIDE_DOXYGEN)
+    using std::basic_filebuf;
+    using std::filebuf;
+#else // Windows
+    
+    ///
+    /// \brief This forward declaration defined the basic_filebuf type.
+    ///
+    /// it is implemented and specialized for CharType = char, it behaves
+    /// implements std::filebuf over standard C I/O
+    ///
+    template<typename CharType,typename Traits = std::char_traits<CharType> >
+    class basic_filebuf;
+    
+    ///
+    /// \brief This is implementation of std::filebuf
+    ///
+    /// it is implemented and specialized for CharType = char, it behaves
+    /// implements std::filebuf over standard C I/O
+    ///
+    template<>
+    class basic_filebuf<char> : public std::basic_streambuf<char> {
+    public:
+        ///
+        /// Creates new filebuf
+        ///
+        basic_filebuf() : 
+            buffer_size_(4),
+            buffer_(0),
+            file_(0),
+            own_(true),
+            mode_(std::ios::in | std::ios::out)
+        {
+            setg(0,0,0);
+            setp(0,0);
+        }
+        
+        virtual ~basic_filebuf()
+        {
+            if(file_) {
+                ::fclose(file_);
+                file_ = 0;
+            }
+            if(own_ && buffer_)
+                delete [] buffer_;
+        }
+        
+        ///
+        /// Same as std::filebuf::open but s is UTF-8 string
+        ///
+        basic_filebuf *open(std::string const &s,std::ios_base::openmode mode)
+        {
+            return open(s.c_str(),mode);
+        }
+        ///
+        /// Same as std::filebuf::open but s is UTF-8 string
+        ///
+        basic_filebuf *open(char const *s,std::ios_base::openmode mode)
+        {
+            if(file_) {
+                sync();
+                ::fclose(file_);
+                file_ = 0;
+            }
+            bool ate = bool(mode & std::ios_base::ate);
+            if(ate)
+                mode = mode ^ std::ios_base::ate;
+            wchar_t const *smode = get_mode(mode);
+            if(!smode)
+                return 0;
+            wstackstring name;
+            if(!name.convert(s)) 
+                return 0;
+            #ifdef NOWIDE_FSTREAM_TESTS
+            FILE *f = ::fopen(s,nowide::convert(smode).c_str());
+            #else
+            FILE *f = ::_wfopen(name.c_str(),smode);
+            #endif
+            if(!f)
+                return 0;
+            if(ate && fseek(f,0,SEEK_END)!=0) {
+                fclose(f);
+                return 0;
+            }
+            file_ = f;
+            return this;
+        }
+        ///
+        /// Same as std::filebuf::close()
+        ///
+        basic_filebuf *close()
+        {
+            bool res = sync() == 0;
+            if(file_) {
+                if(::fclose(file_)!=0)
+                    res = false;
+                file_ = 0;
+            }
+            return res ? this : 0;
+        }
+        ///
+        /// Same as std::filebuf::is_open()
+        ///
+        bool is_open() const
+        {
+            return file_ != 0;
+        }
+
+    private:
+        void make_buffer()
+        {
+            if(buffer_)
+                return;
+            if(buffer_size_ > 0) {
+                buffer_ = new char [buffer_size_];
+                own_ = true;
+            }
+        }
+    protected:
+        
+        virtual std::streambuf *setbuf(char *s,std::streamsize n)
+        {
+            if(!buffer_ && n>=0) {
+                buffer_ = s;
+                buffer_size_ = n;
+                own_ = false;
+            }
+            return this;
+        }
+        
+#ifdef NOWIDE_DEBUG_FILEBUF
+
+        void print_buf(char *b,char *p,char *e)
+        {
+            std::cerr << "-- Is Null: " << (b==0) << std::endl;; 
+            if(b==0)
+                return;
+            if(e != 0)
+                std::cerr << "-- Total: " << e - b <<" offset from start " << p - b << std::endl;
+            else
+                std::cerr << "-- Total: " << p - b << std::endl;
+                
+            std::cerr << "-- [";
+            for(char *ptr = b;ptr<p;ptr++)
+                std::cerr << *ptr;
+            if(e!=0) {
+                std::cerr << "|";
+                for(char *ptr = p;ptr<e;ptr++)
+                    std::cerr << *ptr;
+            }
+            std::cerr << "]" << std::endl;
+           
+        }
+        
+        void print_state()
+        {
+            std::cerr << "- Output:" << std::endl;
+            print_buf(pbase(),pptr(),0);
+            std::cerr << "- Input:" << std::endl;
+            print_buf(eback(),gptr(),egptr());
+            std::cerr << "- fpos: " << (file_ ? ftell(file_) : -1L) << std::endl;
+        }
+        
+        struct print_guard
+        {
+            print_guard(basic_filebuf *p,char const *func)
+            {
+                self = p;
+                f=func;
+                std::cerr << "In: " << f << std::endl;
+                self->print_state();
+            }
+            ~print_guard()
+            {
+                std::cerr << "Out: " << f << std::endl;
+                self->print_state();
+            }
+            basic_filebuf *self;
+            char const *f;
+        };
+#else
+#endif        
+        
+        int overflow(int c)
+        {
+#ifdef NOWIDE_DEBUG_FILEBUF
+            print_guard g(this,__FUNCTION__);
+#endif            
+            if(!file_)
+                return EOF;
+            
+            if(fixg() < 0)
+                return EOF;
+
+            size_t n = pptr() - pbase();
+            if(n > 0) {
+                if(::fwrite(pbase(),1,n,file_) < n)
+                    return -1;
+                fflush(file_);
+            }
+
+            if(buffer_size_ > 0) {
+                make_buffer();
+                setp(buffer_,buffer_+buffer_size_);
+                if(c!=EOF)
+                    sputc(c);
+            }
+            else if(c!=EOF) {
+                if(::fputc(c,file_)==EOF)
+                    return EOF;
+                fflush(file_);
+            }
+            return 0;
+        }
+        
+        
+        int sync()
+        {
+            return overflow(EOF);
+        }
+
+        int underflow()
+        {
+#ifdef NOWIDE_DEBUG_FILEBUF
+            print_guard g(this,__FUNCTION__);
+#endif            
+            if(!file_)
+                return EOF;
+            if(fixp() < 0)
+                return EOF;
+            if(buffer_size_ == 0) {
+                int c = ::fgetc(file_);
+                if(c==EOF) {
+                    return EOF;
+                }
+                last_char_ = c;
+                setg(&last_char_,&last_char_,&last_char_ + 1);
+                return c;
+            }
+            make_buffer();
+            size_t n = ::fread(buffer_,1,buffer_size_,file_);
+            setg(buffer_,buffer_,buffer_+n);
+            if(n == 0)
+                return EOF;
+            return std::char_traits<char>::to_int_type(*gptr());
+        }
+
+        int pbackfail(int)
+        {
+            return pubseekoff(-1,std::ios::cur);
+        }
+
+        std::streampos seekoff(std::streamoff off,
+                            std::ios_base::seekdir seekdir,
+                            std::ios_base::openmode /*m*/)
+        {
+#ifdef NOWIDE_DEBUG_FILEBUF
+            print_guard g(this,__FUNCTION__);
+#endif            
+            if(!file_)
+                return EOF;
+            if(fixp() < 0 || fixg() < 0)
+                return EOF;
+            if(seekdir == std::ios_base::cur) {
+                if( ::fseek(file_,off,SEEK_CUR) < 0)
+                    return EOF;
+            }
+            else if(seekdir == std::ios_base::beg) {
+                if( ::fseek(file_,off,SEEK_SET) < 0)
+                    return EOF;
+            }
+            else if(seekdir == std::ios_base::end) {
+                if( ::fseek(file_,off,SEEK_END) < 0)
+                    return EOF;
+            }
+            else
+                return -1;
+            return ftell(file_);
+        }
+        std::streampos seekpos(std::streampos off,std::ios_base::openmode m)
+        {
+            return seekoff(std::streamoff(off),std::ios_base::beg,m);
+        }
+    private:
+        int fixg()
+        {
+            if(gptr()!=egptr()) {
+                std::streamsize off = gptr() - egptr();
+                setg(0,0,0);
+                if(fseek(file_,off,SEEK_CUR) != 0)
+                    return -1;
+            }
+            setg(0,0,0);
+            return 0;
+        }
+        
+        int fixp()
+        {
+            if(pptr()!=0) {
+                int r = sync();
+                setp(0,0);
+                return r;
+            }
+            return 0;
+        }
+
+        void reset(FILE *f = 0)
+        {
+            sync();
+            if(file_) {
+                fclose(file_);
+                file_ = 0;
+            }
+            file_ = f;
+        }
+        
+        
+        static wchar_t const *get_mode(std::ios_base::openmode mode)
+        {
+            //
+            // done according to n2914 table 106 27.9.1.4
+            //
+
+            // note can't use switch case as overload operator can't be used
+            // in constant expression
+            if(mode == (std::ios_base::out))
+                return L"w";
+            if(mode == (std::ios_base::out | std::ios_base::app))
+                return L"a";
+            if(mode == (std::ios_base::app))
+                return L"a";
+            if(mode == (std::ios_base::out | std::ios_base::trunc))
+                return L"w";
+            if(mode == (std::ios_base::in))
+                return L"r";
+            if(mode == (std::ios_base::in | std::ios_base::out))
+                return L"r+";
+            if(mode == (std::ios_base::in | std::ios_base::out | std::ios_base::trunc))
+                return L"w+";
+            if(mode == (std::ios_base::in | std::ios_base::out | std::ios_base::app))
+                return L"a+";
+            if(mode == (std::ios_base::in | std::ios_base::app))
+                return L"a+";
+            if(mode == (std::ios_base::binary | std::ios_base::out))
+                return L"wb";
+            if(mode == (std::ios_base::binary | std::ios_base::out | std::ios_base::app))
+                return L"ab";
+            if(mode == (std::ios_base::binary | std::ios_base::app))
+                return L"ab";
+            if(mode == (std::ios_base::binary | std::ios_base::out | std::ios_base::trunc))
+                return L"wb";
+            if(mode == (std::ios_base::binary | std::ios_base::in))
+                return L"rb";
+            if(mode == (std::ios_base::binary | std::ios_base::in | std::ios_base::out))
+                return L"r+b";
+            if(mode == (std::ios_base::binary | std::ios_base::in | std::ios_base::out | std::ios_base::trunc))
+                return L"w+b";
+            if(mode == (std::ios_base::binary | std::ios_base::in | std::ios_base::out | std::ios_base::app))
+                return L"a+b";
+            if(mode == (std::ios_base::binary | std::ios_base::in | std::ios_base::app))
+                return L"a+b";
+            return 0;    
+        }
+        
+        size_t buffer_size_;
+        char *buffer_;
+        FILE *file_;
+        bool own_;
+        char last_char_;
+        std::ios::openmode mode_;
+    };
+    
+    ///
+    /// \brief Convinience typedef
+    ///
+    typedef basic_filebuf<char> filebuf;
+    
+    #endif // windows
+    
+} // nowide
+
+
+#ifdef NOWIDE_MSVC
+#  pragma warning(pop)
+#endif
+
+
+#endif
+
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/fstream.hpp b/src/Plugins/Windows/nowide/fstream.hpp
new file mode 100755
index 0000000..852d087
--- /dev/null
+++ b/src/Plugins/Windows/nowide/fstream.hpp
@@ -0,0 +1,283 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_FSTREAM_INCLUDED_HPP
+#define NOWIDE_FSTREAM_INCLUDED_HPP
+
+#include <iosfwd>
+#include <nowide/config.hpp>
+#include <nowide/convert.hpp>
+#include <nowide/scoped_ptr.hpp>
+#include <fstream>
+#include <memory>
+#include <nowide/filebuf.hpp>
+
+
+///
+/// \brief This namespace includes implementation of the standard library functios
+/// such that they accept UTF-8 strings on Windows. On other platforms it is just an alias
+/// of std namespace (i.e. not on Windows)
+///
+namespace nowide {
+#if !defined(NOWIDE_WINDOWS)  && !defined(NOWIDE_FSTREAM_TESTS) && !defined(NOWIDE_DOXYGEN)
+
+    using std::basic_ifstream;
+    using std::basic_ofstream;
+    using std::basic_fstream;
+    using std::ifstream;
+    using std::ofstream;
+    using std::fstream;
+
+#else
+    ///
+    /// \brief Same as std::basic_ifstream<char> but accepts UTF-8 strings under Windows
+    ///
+    template<typename CharType,typename Traits = std::char_traits<CharType> >
+    class basic_ifstream : public std::basic_istream<CharType,Traits>
+    {
+    public:
+        typedef basic_filebuf<CharType,Traits> internal_buffer_type;
+        typedef std::basic_istream<CharType,Traits> internal_stream_type;
+
+        basic_ifstream() : 
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+        }
+        
+        explicit basic_ifstream(char const *file_name,std::ios_base::openmode mode = std::ios_base::in) : 
+            internal_stream_type(0) 
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+            open(file_name,mode);
+        }
+
+        explicit basic_ifstream(std::string const &file_name,std::ios_base::openmode mode = std::ios_base::in) : 
+            internal_stream_type(0) 
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+            open(file_name,mode);
+        }
+
+        
+        void open(std::string const &file_name,std::ios_base::openmode mode = std::ios_base::in)
+        {
+            open(file_name.c_str(),mode);
+        }
+        void open(char const *file_name,std::ios_base::openmode mode = std::ios_base::in)
+        {
+            if(!buf_->open(file_name,mode | std::ios_base::in)) {
+                this->setstate(std::ios_base::failbit);
+            }
+            else {
+                this->clear();
+            }
+        }
+        bool is_open()
+        {
+            return buf_->is_open();
+        }
+        bool is_open() const
+        {
+            return buf_->is_open();
+        }
+        void close()
+        {
+            if(!buf_->close())
+                this->setstate(std::ios_base::failbit);
+            else
+                this->clear();
+        }
+
+        internal_buffer_type *rdbuf() const
+        {
+            return buf_.get();
+        }
+        ~basic_ifstream()
+        {
+            buf_->close();
+        }
+            
+    private:
+        nowide::scoped_ptr<internal_buffer_type> buf_;
+    };
+
+    ///
+    /// \brief Same as std::basic_ofstream<char> but accepts UTF-8 strings under Windows
+    ///
+
+    template<typename CharType,typename Traits = std::char_traits<CharType> >
+    class basic_ofstream : public std::basic_ostream<CharType,Traits>
+    {
+    public:
+        typedef basic_filebuf<CharType,Traits> internal_buffer_type;
+        typedef std::basic_ostream<CharType,Traits> internal_stream_type;
+
+        basic_ofstream() : 
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+        }
+        explicit basic_ofstream(char const *file_name,std::ios_base::openmode mode = std::ios_base::out) :
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+            open(file_name,mode);
+        }
+        explicit basic_ofstream(std::string const &file_name,std::ios_base::openmode mode = std::ios_base::out) :
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+            open(file_name,mode);
+        }
+        void open(std::string const &file_name,std::ios_base::openmode mode = std::ios_base::out)
+        {
+            open(file_name.c_str(),mode);
+        }
+        void open(char const *file_name,std::ios_base::openmode mode = std::ios_base::out)
+        {
+            if(!buf_->open(file_name,mode | std::ios_base::out)) {
+                this->setstate(std::ios_base::failbit);
+            }
+            else {
+                this->clear();
+            }
+        }
+        bool is_open()
+        {
+            return buf_->is_open();
+        }
+        bool is_open() const
+        {
+            return buf_->is_open();
+        }
+        void close()
+        {
+            if(!buf_->close())
+                this->setstate(std::ios_base::failbit);
+            else
+                this->clear();
+        }
+
+        internal_buffer_type *rdbuf() const
+        {
+            return buf_.get();
+        }
+        ~basic_ofstream()
+        {
+            buf_->close();
+        }
+            
+    private:
+        nowide::scoped_ptr<internal_buffer_type> buf_;
+    };
+
+    ///
+    /// \brief Same as std::basic_fstream<char> but accepts UTF-8 strings under Windows
+    ///
+
+    template<typename CharType,typename Traits = std::char_traits<CharType> >
+    class basic_fstream : public std::basic_iostream<CharType,Traits>
+    {
+    public:
+        typedef basic_filebuf<CharType,Traits> internal_buffer_type;
+        typedef std::basic_iostream<CharType,Traits> internal_stream_type;
+
+        basic_fstream() : 
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+        }
+        explicit basic_fstream(char const *file_name,std::ios_base::openmode mode = std::ios_base::out | std::ios_base::in) :
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+            open(file_name,mode);
+        }
+        explicit basic_fstream(std::string const &file_name,std::ios_base::openmode mode = std::ios_base::out | std::ios_base::in) :
+            internal_stream_type(0)
+        {
+            buf_.reset(new internal_buffer_type());
+            std::ios::rdbuf(buf_.get());
+            open(file_name,mode);
+        }
+        void open(std::string const &file_name,std::ios_base::openmode mode = std::ios_base::out | std::ios_base::out)
+        {
+            open(file_name.c_str(),mode);
+        }
+        void open(char const *file_name,std::ios_base::openmode mode = std::ios_base::out | std::ios_base::out)
+        {
+            if(!buf_->open(file_name,mode)) {
+                this->setstate(std::ios_base::failbit);
+            }
+            else {
+                this->clear();
+            }
+        }
+        bool is_open()
+        {
+            return buf_->is_open();
+        }
+        bool is_open() const
+        {
+            return buf_->is_open();
+        }
+        void close()
+        {
+            if(!buf_->close())
+                this->setstate(std::ios_base::failbit);
+            else
+                this->clear();
+        }
+
+        internal_buffer_type *rdbuf() const
+        {
+            return buf_.get();
+        }
+        ~basic_fstream()
+        {
+            buf_->close();
+        }
+            
+    private:
+        nowide::scoped_ptr<internal_buffer_type> buf_;
+    };
+
+
+    ///
+    /// \brief Same as std::filebuf but accepts UTF-8 strings under Windows
+    ///
+    typedef basic_filebuf<char> filebuf;
+    ///
+    /// Same as std::ifstream but accepts UTF-8 strings under Windows
+    ///
+    typedef basic_ifstream<char> ifstream;
+    ///
+    /// Same as std::ofstream but accepts UTF-8 strings under Windows
+    ///
+    typedef basic_ofstream<char> ofstream;
+    ///
+    /// Same as std::fstream but accepts UTF-8 strings under Windows
+    ///
+    typedef basic_fstream<char> fstream;
+
+#endif
+} // nowide
+
+
+
+
+#endif
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/iostream.hpp b/src/Plugins/Windows/nowide/iostream.hpp
new file mode 100755
index 0000000..b08c477
--- /dev/null
+++ b/src/Plugins/Windows/nowide/iostream.hpp
@@ -0,0 +1,99 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_IOSTREAM_HPP_INCLUDED
+#define NOWIDE_IOSTREAM_HPP_INCLUDED
+
+#include <nowide/config.hpp>
+#include <nowide/scoped_ptr.hpp>
+#include <iostream>
+#include <ostream>
+#include <istream>
+
+#ifdef NOWIDE_MSVC
+#  pragma warning(push)
+#  pragma warning(disable : 4251)
+#endif
+
+
+
+namespace nowide {
+    #if !defined(NOWIDE_WINDOWS) && !defined(NOWIDE_DOXYGEN)
+    using std::cout;
+    using std::cerr;
+    using std::cin;
+    using std::clog;
+    #else
+    
+    /// \cond INTERNAL 
+    namespace details {
+        class console_output_buffer;
+        class console_input_buffer;
+        
+        class NOWIDE_DECL winconsole_ostream : public std::ostream {
+            winconsole_ostream(winconsole_ostream const &);
+            void operator=(winconsole_ostream const &);
+        public:
+            winconsole_ostream(int fd);
+            ~winconsole_ostream();
+        private:
+            nowide::scoped_ptr<console_output_buffer> d;
+        };
+
+        class NOWIDE_DECL winconsole_istream : public std::istream {
+            winconsole_istream(winconsole_istream const &);
+            void operator=(winconsole_istream const &);
+        public:
+            
+            winconsole_istream();
+            ~winconsole_istream();
+        private:
+            struct data;
+            nowide::scoped_ptr<console_input_buffer> d;
+        };
+    } // details 
+    
+    /// \endcond
+
+    ///
+    /// \brief Same as std::cin, but uses UTF-8
+    ///
+    /// Note, the stream is not synchronized with stdio and not affected by std::ios::sync_with_stdio
+    /// 
+    extern NOWIDE_DECL details::winconsole_istream cin;
+    ///
+    /// \brief Same as std::cout, but uses UTF-8
+    ///
+    /// Note, the stream is not synchronized with stdio and not affected by std::ios::sync_with_stdio
+    /// 
+    extern NOWIDE_DECL details::winconsole_ostream cout;
+    ///
+    /// \brief Same as std::cerr, but uses UTF-8
+    ///
+    /// Note, the stream is not synchronized with stdio and not affected by std::ios::sync_with_stdio
+    /// 
+    extern NOWIDE_DECL details::winconsole_ostream cerr;
+    ///
+    /// \brief Same as std::clog, but uses UTF-8
+    ///
+    /// Note, the stream is not synchronized with stdio and not affected by std::ios::sync_with_stdio
+    /// 
+    extern NOWIDE_DECL details::winconsole_ostream clog;
+
+    #endif
+
+} // nowide
+
+
+#ifdef NOWIDE_MSVC
+#  pragma warning(pop)
+#endif
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/scoped_ptr.hpp b/src/Plugins/Windows/nowide/scoped_ptr.hpp
new file mode 100644
index 0000000..92410e2
--- /dev/null
+++ b/src/Plugins/Windows/nowide/scoped_ptr.hpp
@@ -0,0 +1,93 @@
+#ifndef NOWIDE_SCOPED_PTR_HPP
+#define NOWIDE_SCOPED_PTR_HPP
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov, 
+//  Copyright (C) 2012 Artyom Beilis
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  http://www.boost.org/libs/smart_ptr/scoped_ptr.htm
+//
+
+#include <assert.h>
+
+namespace nowide
+{
+
+//  scoped_ptr mimics a built-in pointer except that it guarantees deletion
+//  of the object pointed to, either on destruction of the scoped_ptr or via
+//  an explicit reset(). scoped_ptr is a simple solution for simple needs;
+//  use shared_ptr or std::auto_ptr if your needs are more complex.
+
+template<class T> class scoped_ptr // noncopyable
+{
+private:
+
+    T * px;
+
+    scoped_ptr(scoped_ptr const &);
+    scoped_ptr & operator=(scoped_ptr const &);
+
+    typedef scoped_ptr<T> this_type;
+
+    void operator==( scoped_ptr const& ) const;
+    void operator!=( scoped_ptr const& ) const;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_ptr( T * p = 0 ): px( p ) // never throws
+    {
+    }
+
+    ~scoped_ptr() // never throws
+    {
+        delete px;
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        assert( p == 0 || p != px ); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T & operator*() const // never throws
+    {
+        assert( px != 0 );
+        return *px;
+    }
+
+    T * operator->() const // never throws
+    {
+        assert( px != 0 );
+        return px;
+    }
+
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    operator bool() const
+    {
+        return px!=0;
+    }
+
+    void swap(scoped_ptr & b) // never throws
+    {
+        T * tmp = b.px;
+        b.px = px;
+        px = tmp;
+    }
+};
+
+
+} // namespace nowide
+
+#endif
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
+
diff --git a/src/Plugins/Windows/nowide/stackstring.hpp b/src/Plugins/Windows/nowide/stackstring.hpp
new file mode 100755
index 0000000..c93f983
--- /dev/null
+++ b/src/Plugins/Windows/nowide/stackstring.hpp
@@ -0,0 +1,154 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_DETAILS_WIDESTR_H_INCLUDED
+#define NOWIDE_DETAILS_WIDESTR_H_INCLUDED
+#include <nowide/convert.hpp>
+#include <string.h>
+#include <algorithm>
+
+
+namespace nowide {
+
+///
+/// \brief A class that allows to create a temporary wide or narrow UTF strings from
+/// wide or narrow UTF source.
+///
+/// It uses on stack buffer of the string is short enough
+/// and allocated a buffer on the heap if the size of the buffer is too small
+///    
+template<typename CharOut=wchar_t,typename CharIn = char,size_t BufferSize = 256>
+class basic_stackstring {
+public:
+   
+    static const size_t buffer_size = BufferSize; 
+    typedef CharOut output_char;
+    typedef CharIn input_char;
+
+    basic_stackstring(basic_stackstring const &other) : 
+    mem_buffer_(0)
+    {
+        clear();
+        if(other.mem_buffer_) {
+            size_t len = 0;
+            while(other.mem_buffer_[len])
+                len ++;
+            mem_buffer_ = new output_char[len + 1];
+            memcpy(mem_buffer_,other.mem_buffer_,sizeof(output_char) * (len+1));
+        }
+        else {
+            memcpy(buffer_,other.buffer_,buffer_size * sizeof(output_char));
+        }
+    }
+    
+    void swap(basic_stackstring &other)
+    {
+        std::swap(mem_buffer_,other.mem_buffer_);
+        for(size_t i=0;i<buffer_size;i++)
+            std::swap(buffer_[i],other.buffer_[i]);
+    }
+    basic_stackstring &operator=(basic_stackstring const &other)
+    {
+        if(this != &other) {
+            basic_stackstring tmp(other);
+            swap(tmp);            
+        }
+        return *this;
+    }
+
+    basic_stackstring() : mem_buffer_(0)
+    {
+    }
+    bool convert(input_char const *input)
+    {
+        return convert(input,details::basic_strend(input));
+    }
+    bool convert(input_char const *begin,input_char const *end)
+    {
+        clear();
+
+        size_t space = get_space(sizeof(input_char),sizeof(output_char),end - begin) + 1;
+        if(space <= buffer_size) {
+            if(basic_convert(buffer_,buffer_size,begin,end))
+                return true;
+            clear();
+            return false;
+        }
+        else {
+            mem_buffer_ = new output_char[space];
+            if(!basic_convert(mem_buffer_,space,begin,end)) {
+                clear();
+                return false;
+            }
+            return true;
+        }
+
+    }
+    output_char *c_str()
+    {
+        if(mem_buffer_)
+            return mem_buffer_;
+        return buffer_;
+    }
+    output_char const *c_str() const
+    {
+        if(mem_buffer_)
+            return mem_buffer_;
+        return buffer_;
+    }
+    void clear()
+    {
+        if(mem_buffer_) {
+            delete [] mem_buffer_;
+            mem_buffer_=0;
+        }
+        buffer_[0] = 0;
+    }
+    ~basic_stackstring()
+    {
+        clear();
+    }
+private:
+    static size_t get_space(size_t insize,size_t outsize,size_t in)
+    {
+        if(insize <= outsize)
+            return in;
+        else if(insize == 2 && outsize == 1) 
+            return 3 * in;
+        else if(insize == 4 && outsize == 1) 
+            return 4 * in;
+        else  // if(insize == 4 && outsize == 2) 
+            return 2 * in;
+    }
+    output_char buffer_[buffer_size];
+    output_char *mem_buffer_;
+};  //basic_stackstring
+
+///
+/// Convinience typedef
+///
+typedef basic_stackstring<wchar_t,char,256> wstackstring;
+///
+/// Convinience typedef
+///
+typedef basic_stackstring<char,wchar_t,256> stackstring;
+///
+/// Convinience typedef
+///
+typedef basic_stackstring<wchar_t,char,16> wshort_stackstring;
+///
+/// Convinience typedef
+///
+typedef basic_stackstring<char,wchar_t,16> short_stackstring;
+
+
+} // nowide
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/system.hpp b/src/Plugins/Windows/nowide/system.hpp
new file mode 100755
index 0000000..8083bfc
--- /dev/null
+++ b/src/Plugins/Windows/nowide/system.hpp
@@ -0,0 +1,46 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_CSTDLIB_HPP
+#define NOWIDE_CSTDLIB_HPP
+
+#include <stdlib.h>
+#include <errno.h>
+#include <nowide/stackstring.hpp>
+
+namespace nowide {
+
+#if !defined(NOWIDE_WINDOWS) && !defined(NOWIDE_DOXYGEN)
+
+using ::system;
+
+#else // Windows
+
+///
+/// Same as std::system but cmd is UTF-8.
+///
+/// If the input is not valid UTF-8, -1 returned and errno set to EINVAL
+///
+inline int system(char const *cmd)
+{
+    if(!cmd)
+        return _wsystem(0);
+    wstackstring wcmd;
+    if(!wcmd.convert(cmd)) {
+        errno = EINVAL;
+        return -1;
+    }
+    return _wsystem(wcmd.c_str());
+}
+
+#endif
+} // nowide
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/texmacs_modifications.patch b/src/Plugins/Windows/nowide/texmacs_modifications.patch
new file mode 100644
index 0000000..cbe97bd
--- /dev/null
+++ b/src/Plugins/Windows/nowide/texmacs_modifications.patch
@@ -0,0 +1,144 @@
+--- /tmp/nowide_standalone/nowide/cenv.hpp
++++ /tmp/TeXmacs/src/Plugins/Windows/nowide/cenv.hpp
+@@ -78,6 +78,15 @@
+         wstackstring wval;
+         if(!wval.convert(value))
+             return -1;
++// TeXmacs specific 2017: if Guile is not compiled with nowide we need to set the env variables with (w)putenv too 
++        char * s =  (char*) malloc(strlen(key) + strlen(value) + 2);
++        strcpy(s, key);
++        strcat(s, "=");
++        strcat(s, value);
++        wstackstring ws;
++        ws.convert(s);
++        _wputenv(ws.c_str());
++//end Texmacs specific
+         if(SetEnvironmentVariableW(name.c_str(),wval.c_str()))
+             return 0;
+         return -1;
+@@ -101,7 +110,7 @@
+     {
+         char const *key = string;
+         char const *key_end = string;
+-        while(*key_end!='=' && key_end!='\0')
++        while(*key_end!='=' && *key_end!='\0')
+             key_end++;
+         if(*key_end == '\0')
+             return -1;
+@@ -112,7 +121,11 @@
+         wstackstring wvalue;
+         if(!wvalue.convert(key_end+1))
+             return -1;
+-
++// TeXmacs specific 2017: if Guile is not compiled with nowide we need to set the env variables with (w)putenv too 
++        wstackstring wstring;
++        wstring.convert(string);
++        _wputenv(wstring.c_str());
++//end Texmacs specific
+         if(SetEnvironmentVariableW(wkey.c_str(),wvalue.c_str()))
+             return 0;
+         return -1;
+--- /tmp/nowide_standalone/nowide/cstdio.hpp
++++ /tmp/TeXmacs/src/Plugins/Windows/nowide/cstdio.hpp
+@@ -7,6 +7,10 @@
+ //
+ #ifndef NOWIDE_CSTDIO_H_INCLUDED
+ #define NOWIDE_CSTDIO_H_INCLUDED
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <dirent.h>
+ 
+ #include <cstdio>
+ #include <stdio.h>
+@@ -75,7 +79,7 @@
+     return _wrename(wold.c_str(),wnew.c_str());
+ }
+ ///
+-/// \brief Same as rename but name is UTF-8 string
++/// \brief Same as remove but name is UTF-8 string
+ ///
+ /// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
+ ///
+@@ -86,8 +90,79 @@
+         errno = EINVAL;
+         return -1;
+     }
+-    return _wremove(wname.c_str());
++    int retval;
++    retval = _wremove(wname.c_str());
++    return (retval == -1)? _wrmdir (wname.c_str()) : retval;
+ }
++///
++/// \brief Same as chmod but file_name and mode are UTF-8 strings
++///
++/// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
++///
++inline int chmod(char const *name, int const mode)
++{
++    wstackstring wname;
++    if(!wname.convert(name) ) {
++        errno = EINVAL;
++        return -1;
++    }
++    return _wchmod (wname.c_str(), mode);
++}
++	
++///
++/// \brief Same as mkdir but file_name and mode are UTF-8 strings
++///
++/// If invalid UTF-8 given, -1 is returned and errno is set to EINVAL
++///
++inline int mkdir(char const *name, int const mode)
++{
++    wstackstring wname;
++    if(!wname.convert(name) ) {
++        errno = EINVAL;
++        return -1;
++    }
++    return _wmkdir (wname.c_str());
++}
++#include <sys/stat.h>
++inline int stat(char const *name, struct_stat *buf)
++{
++    wstackstring wname;
++    if(!wname.convert(name)) {
++        errno = EINVAL;
++        return -1;
++    }
++    return _wstat32(wname.c_str(), buf);
++}
++typedef _WDIR DIR;
++inline DIR* opendir(char const *name)
++{
++    wstackstring wname;
++    if(!wname.convert(name) ) {
++        errno = EINVAL;
++        return NULL;
++    }
++    return _wopendir (wname.c_str());
++}
++
++inline char* readir_entry(DIR* dir)
++{
++  struct _wdirent *wentry;
++  wentry = _wreaddir (dir);
++  while (wentry 
++	     && (0 == wcscmp (wentry->d_name, L".") ||
++		 0 == wcscmp (wentry->d_name, L"..")))
++	     wentry = _wreaddir (dir);
++  if (wentry == NULL) return NULL;
++  else { 
++  stackstring entry;
++    if(!entry.convert(wentry->d_name) ) {
++        errno = EINVAL;
++        return NULL;
++    }
++    else return entry.c_str();
++  }
++} 
++
+ #endif
+ } // nowide
+ 
+
diff --git a/src/Plugins/Windows/nowide/utf.hpp b/src/Plugins/Windows/nowide/utf.hpp
new file mode 100755
index 0000000..55dc2cc
--- /dev/null
+++ b/src/Plugins/Windows/nowide/utf.hpp
@@ -0,0 +1,469 @@
+//
+//  Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_UTF_HPP_INCLUDED
+#define NOWIDE_UTF_HPP_INCLUDED
+
+#include <nowide/config.hpp>
+
+#ifndef NOWIDE_MSVC
+namespace nowide  {
+namespace utf {
+    typedef unsigned uint32_t;
+    typedef unsigned short uint16_t;
+    typedef unsigned char uint8_t;
+}
+}
+#else
+#include <stdint.h>
+#endif
+
+namespace nowide {
+///
+/// \brief Namespace that holds basic operations on UTF encoded sequences 
+///
+/// All functions defined in this namespace do not require linking with Boost.Locale library
+///
+namespace utf {
+    /// \cond INTERNAL
+    #ifdef __GNUC__
+    #   define NOWIDE_LIKELY(x)   __builtin_expect((x),1)
+    #   define NOWIDE_UNLIKELY(x) __builtin_expect((x),0)
+    #else
+    #   define NOWIDE_LIKELY(x)   (x)
+    #   define NOWIDE_UNLIKELY(x) (x)
+    #endif
+    /// \endcond
+
+    ///
+    /// \brief The integral type type that can hold a Unicode code point
+    ///
+    typedef uint32_t code_point;
+
+    ///
+    /// \brief Special constant that defines illegal code point
+    ///
+    static const code_point illegal = 0xFFFFFFFFu;
+
+    ///
+    /// \brief Special constant that defines incomplete code point
+    ///
+    static const code_point incomplete = 0xFFFFFFFEu;
+
+    ///
+    /// \brief the function checks if \a v is a valid code point
+    ///
+    inline bool is_valid_codepoint(code_point v)
+    {
+        if(v>0x10FFFF)
+            return false;
+        if(0xD800 <=v && v<= 0xDFFF) // surragates
+            return false;
+        return true;
+    }
+
+    #ifdef NOWIDE_DOXYGEN
+    ///
+    /// \brief UTF Traits class - functions to convert UTF sequences to and from Unicode code points
+    ///
+    template<typename CharType,int size=sizeof(CharType)>
+    struct utf_traits {
+        ///
+        /// The type of the character
+        ///
+        typedef CharType char_type;
+        ///
+        /// Read one code point from the range [p,e) and return it.
+        ///
+        /// - If the sequence that was read is incomplete sequence returns \ref incomplete,
+        /// - If illegal sequence detected returns \ref illegal
+        ///
+        /// Requirements
+        ///
+        /// - Iterator is valid input iterator
+        ///
+        /// Postconditions
+        ///
+        /// - p points to the last consumed character
+        /// 
+        template<typename Iterator>
+        static code_point decode(Iterator &p,Iterator e);
+
+        ///
+        /// Maximal width of valid sequence in the code units:
+        ///
+        /// - UTF-8  - 4
+        /// - UTF-16 - 2
+        /// - UTF-32 - 1
+        ///
+        static const int max_width;
+        ///
+        /// The width of specific code point in the code units.
+        ///
+        /// Requirement: value is a valid Unicode code point
+        /// Returns value in range [1..max_width]
+        ///
+        static int width(code_point value);
+
+        ///
+        /// Get the size of the trail part of variable length encoded sequence.
+        ///
+        /// Returns -1 if C is not valid lead character
+        /// 
+        static int trail_length(char_type c);
+        ///
+        /// Returns true if c is trail code unit, always false for UTF-32
+        ///
+        static bool is_trail(char_type c);
+        ///
+        /// Returns true if c is lead code unit, always true of UTF-32
+        ///
+        static bool is_lead(char_type c);
+
+        ///
+        /// Convert valid Unicode code point \a value to the UTF sequence.
+        ///
+        /// Requirements: 
+        ///
+        /// - \a value is valid code point
+        /// - \a out is an output iterator should be able to accept at least width(value) units
+        /// 
+        /// Returns the iterator past the last written code unit.
+        ///
+        template<typename Iterator>
+        static Iterator encode(code_point value,Iterator out);
+        ///
+        /// Decodes valid UTF sequence that is pointed by p into code point.
+        ///
+        /// If the sequence is invalid or points to end the behavior is undefined
+        ///
+        template<typename Iterator>
+        static code_point decode_valid(Iterator &p);
+    };
+    
+    #else
+
+    template<typename CharType,int size=sizeof(CharType)>
+    struct utf_traits;
+
+    template<typename CharType>
+    struct utf_traits<CharType,1> {
+
+        typedef CharType char_type;
+        
+        static int trail_length(char_type ci) 
+        {
+            unsigned char c = ci;
+            if(c < 128)
+                return 0;
+            if(NOWIDE_UNLIKELY(c < 194))
+                return -1;
+            if(c < 224)
+                return 1;
+            if(c < 240)
+                return 2;
+            if(NOWIDE_LIKELY(c <=244))
+                return 3;
+            return -1;
+        }
+        
+        static const int max_width = 4;
+
+        static int width(code_point value)
+        {
+            if(value <=0x7F) {
+                return 1;
+            }
+            else if(value <=0x7FF) {
+                return 2;
+            }
+            else if(NOWIDE_LIKELY(value <=0xFFFF)) {
+                return 3;
+            }
+            else {
+                return 4;
+            }
+        }
+
+        static bool is_trail(char_type ci)
+        {
+            unsigned char c=ci;
+            return (c & 0xC0)==0x80;
+        }
+
+        static bool is_lead(char_type ci)
+        {
+            return !is_trail(ci);
+        }
+        
+        template<typename Iterator>
+        static code_point decode(Iterator &p,Iterator e)
+        {
+            if(NOWIDE_UNLIKELY(p==e))
+                return incomplete;
+
+            unsigned char lead = *p++;
+
+            // First byte is fully validated here
+            int trail_size = trail_length(lead);
+
+            if(NOWIDE_UNLIKELY(trail_size < 0))
+                return illegal;
+
+            //
+            // Ok as only ASCII may be of size = 0
+            // also optimize for ASCII text
+            //
+            if(trail_size == 0)
+                return lead;
+            
+            code_point c = lead & ((1<<(6-trail_size))-1);
+
+            // Read the rest
+            unsigned char tmp;
+            switch(trail_size) {
+            case 3:
+                if(NOWIDE_UNLIKELY(p==e))
+                    return incomplete;
+                tmp = *p++;
+                if (!is_trail(tmp))
+                    return illegal;
+                c = (c << 6) | ( tmp & 0x3F);
+            case 2:
+                if(NOWIDE_UNLIKELY(p==e))
+                    return incomplete;
+                tmp = *p++;
+                if (!is_trail(tmp))
+                    return illegal;
+                c = (c << 6) | ( tmp & 0x3F);
+            case 1:
+                if(NOWIDE_UNLIKELY(p==e))
+                    return incomplete;
+                tmp = *p++;
+                if (!is_trail(tmp))
+                    return illegal;
+                c = (c << 6) | ( tmp & 0x3F);
+            }
+
+            // Check code point validity: no surrogates and
+            // valid range
+            if(NOWIDE_UNLIKELY(!is_valid_codepoint(c)))
+                return illegal;
+
+            // make sure it is the most compact representation
+            if(NOWIDE_UNLIKELY(width(c)!=trail_size + 1))
+                return illegal;
+
+            return c;
+
+        }
+        
+        template<typename Iterator>
+        static code_point decode_valid(Iterator &p)
+        {
+            unsigned char lead = *p++;
+            if(lead < 192)
+                return lead;
+
+            int trail_size;
+
+            if(lead < 224)
+                trail_size = 1;
+            else if(NOWIDE_LIKELY(lead < 240)) // non-BMP rare
+                trail_size = 2;
+            else
+                trail_size = 3;
+            
+            code_point c = lead & ((1<<(6-trail_size))-1);
+
+            switch(trail_size) {
+            case 3:
+                c = (c << 6) | ( static_cast<unsigned char>(*p++) & 0x3F);
+            case 2:
+                c = (c << 6) | ( static_cast<unsigned char>(*p++) & 0x3F);
+            case 1:
+                c = (c << 6) | ( static_cast<unsigned char>(*p++) & 0x3F);
+            }
+
+            return c;
+        }
+
+
+
+        template<typename Iterator>
+        static Iterator encode(code_point value,Iterator out)
+        {
+            if(value <= 0x7F) {
+                *out++ = static_cast<char_type>(value);
+            }
+            else if(value <= 0x7FF) {
+                *out++ = static_cast<char_type>((value >> 6) | 0xC0);
+                *out++ = static_cast<char_type>((value & 0x3F) | 0x80);
+            }
+            else if(NOWIDE_LIKELY(value <= 0xFFFF)) {
+                *out++ = static_cast<char_type>((value >> 12) | 0xE0);
+                *out++ = static_cast<char_type>(((value >> 6) & 0x3F) | 0x80);
+                *out++ = static_cast<char_type>((value & 0x3F) | 0x80);
+            }
+            else {
+                *out++ = static_cast<char_type>((value >> 18) | 0xF0);
+                *out++ = static_cast<char_type>(((value >> 12) & 0x3F) | 0x80);
+                *out++ = static_cast<char_type>(((value >> 6) & 0x3F) | 0x80);
+                *out++ = static_cast<char_type>((value & 0x3F) | 0x80);
+            }
+            return out;
+        }
+    }; // utf8
+
+    template<typename CharType>
+    struct utf_traits<CharType,2> {
+        typedef CharType char_type;
+
+        // See RFC 2781
+        static bool is_first_surrogate(uint16_t x)
+        {
+            return 0xD800 <=x && x<= 0xDBFF;
+        }
+        static bool is_second_surrogate(uint16_t x)
+        {
+            return 0xDC00 <=x && x<= 0xDFFF;
+        }
+        static code_point combine_surrogate(uint16_t w1,uint16_t w2)
+        {
+            return ((code_point(w1 & 0x3FF) << 10) | (w2 & 0x3FF)) + 0x10000;
+        }
+        static int trail_length(char_type c)
+        {
+            if(is_first_surrogate(c))
+                return 1;
+            if(is_second_surrogate(c))
+                return -1;
+            return 0;
+        }
+        ///
+        /// Returns true if c is trail code unit, always false for UTF-32
+        ///
+        static bool is_trail(char_type c)
+        {
+            return is_second_surrogate(c);
+        }
+        ///
+        /// Returns true if c is lead code unit, always true of UTF-32
+        ///
+        static bool is_lead(char_type c)
+        {
+            return !is_second_surrogate(c);
+        }
+
+        template<typename It>
+        static code_point decode(It &current,It last)
+        {
+            if(NOWIDE_UNLIKELY(current == last))
+                return incomplete;
+            uint16_t w1=*current++;
+            if(NOWIDE_LIKELY(w1 < 0xD800 || 0xDFFF < w1)) {
+                return w1;
+            }
+            if(w1 > 0xDBFF)
+                return illegal;
+            if(current==last)
+                return incomplete;
+            uint16_t w2=*current++;
+            if(w2 < 0xDC00 || 0xDFFF < w2)
+                return illegal;
+            return combine_surrogate(w1,w2);
+        }
+        template<typename It>
+        static code_point decode_valid(It &current)
+        {
+            uint16_t w1=*current++;
+            if(NOWIDE_LIKELY(w1 < 0xD800 || 0xDFFF < w1)) {
+                return w1;
+            }
+            uint16_t w2=*current++;
+            return combine_surrogate(w1,w2);
+        }
+
+        static const int max_width = 2;
+        static int width(code_point u)
+        {
+            return u>=0x10000 ? 2 : 1;
+        }
+        template<typename It>
+        static It encode(code_point u,It out)
+        {
+            if(NOWIDE_LIKELY(u<=0xFFFF)) {
+                *out++ = static_cast<char_type>(u);
+            }
+            else {
+                u -= 0x10000;
+                *out++ = static_cast<char_type>(0xD800 | (u>>10));
+                *out++ = static_cast<char_type>(0xDC00 | (u & 0x3FF));
+            }
+            return out;
+        }
+    }; // utf16;
+
+        
+    template<typename CharType>
+    struct utf_traits<CharType,4> {
+        typedef CharType char_type;
+        static int trail_length(char_type c)
+        {
+            if(is_valid_codepoint(c))
+                return 0;
+            return -1;
+        }
+        static bool is_trail(char_type /*c*/)
+        {
+            return false;
+        }
+        static bool is_lead(char_type /*c*/)
+        {
+            return true;
+        }
+
+        template<typename It>
+        static code_point decode_valid(It &current)
+        {
+            return *current++;
+        }
+
+        template<typename It>
+        static code_point decode(It &current,It last)
+        {
+            if(NOWIDE_UNLIKELY(current == last))
+                return nowide::utf::incomplete;
+            code_point c=*current++;
+            if(NOWIDE_UNLIKELY(!is_valid_codepoint(c)))
+                return nowide::utf::illegal;
+            return c;
+        }
+        static const int max_width = 1;
+        static int width(code_point /*u*/)
+        {
+            return 1;
+        }
+        template<typename It>
+        static It encode(code_point u,It out)
+        {
+            *out++ = static_cast<char_type>(u);
+            return out;
+        }
+
+    }; // utf32
+
+    #endif
+
+} // utf
+} // nowide
+
+
+#endif
+
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
+
diff --git a/src/Plugins/Windows/nowide/utf8_codecvt.hpp b/src/Plugins/Windows/nowide/utf8_codecvt.hpp
new file mode 100755
index 0000000..32de5d1
--- /dev/null
+++ b/src/Plugins/Windows/nowide/utf8_codecvt.hpp
@@ -0,0 +1,499 @@
+//
+//  Copyright (c) 2015 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_UTF8_CODECVT_HPP
+#define NOWIDE_UTF8_CODECVT_HPP
+
+#include <nowide/utf.hpp>
+#include <nowide/cstdint.hpp>
+#include <nowide/static_assert.hpp>
+#include <locale>
+
+
+namespace nowide {
+
+//
+// Make sure that mbstate can keep 16 bit of UTF-16 sequence
+//
+NOWIDE_STATIC_ASSERT(sizeof(std::mbstate_t)>=2);
+
+#if defined _MSC_VER && _MSC_VER < 1700
+// MSVC do_length is non-standard it counts wide characters instead of narrow and does not change mbstate
+#define NOWIDE_DO_LENGTH_MBSTATE_CONST
+#endif
+
+template<typename CharType,int CharSize=sizeof(CharType)>
+class utf8_codecvt;
+
+template<typename CharType>
+class utf8_codecvt<CharType,2> : public std::codecvt<CharType,char,std::mbstate_t>
+{
+public:
+    utf8_codecvt(size_t refs = 0) : std::codecvt<CharType,char,std::mbstate_t>(refs)
+    {
+    }
+protected:
+
+    typedef CharType uchar;
+
+    virtual std::codecvt_base::result do_unshift(std::mbstate_t &s,char *from,char * /*to*/,char *&next) const
+    {
+        nowide::uint16_t &state = *reinterpret_cast<nowide::uint16_t *>(&s);
+#ifdef DEBUG_CODECVT            
+        std::cout << "Entering unshift " << std::hex << state << std::dec << std::endl;
+#endif            
+        if(state != 0)
+            return std::codecvt_base::error;
+        next=from;
+        return std::codecvt_base::ok;
+    }
+    virtual int do_encoding() const throw()
+    {
+        return 0;
+    }
+    virtual int do_max_length() const throw()
+    {
+        return 4;
+    }
+    virtual bool do_always_noconv() const throw()
+    {
+        return false;
+    }
+
+    virtual int
+    do_length(  std::mbstate_t 
+    #ifdef NOWIDE_DO_LENGTH_MBSTATE_CONST
+            const   
+    #endif
+            &std_state,
+            char const *from,
+            char const *from_end,
+            size_t max) const
+    {
+        #ifndef NOWIDE_DO_LENGTH_MBSTATE_CONST
+        char const *save_from = from;
+        nowide::uint16_t &state = *reinterpret_cast<nowide::uint16_t *>(&std_state);
+        #else
+        size_t save_max = max;
+        nowide::uint16_t state = *reinterpret_cast<nowide::uint16_t const *>(&std_state);
+        #endif
+        while(max > 0 && from < from_end){
+            char const *prev_from = from;
+            nowide::uint32_t ch=nowide::utf::utf_traits<char>::decode(from,from_end);
+            if(ch==nowide::utf::incomplete || ch==nowide::utf::illegal) {
+                from = prev_from;
+                break;
+            }
+            max --;
+            if(ch > 0xFFFF) {
+                if(state == 0) {
+                    from = prev_from;
+                    state = 1;
+                }
+                else {
+                    state = 0;
+                }
+            }        
+        }
+        #ifndef NOWIDE_DO_LENGTH_MBSTATE_CONST
+        return from - save_from;
+        #else
+        return save_max - max;
+        #endif
+    }
+
+    
+    virtual std::codecvt_base::result 
+    do_in(  std::mbstate_t &std_state,
+            char const *from,
+            char const *from_end,
+            char const *&from_next,
+            uchar *to,
+            uchar *to_end,
+            uchar *&to_next) const
+    {
+        std::codecvt_base::result r=std::codecvt_base::ok;
+        
+        // mbstate_t is POD type and should be initialized to 0 (i.a. state = stateT())
+        // according to standard. We use it to keep a flag 0/1 for surrogate pair writing
+        //
+        // if 0 no code above >0xFFFF observed, of 1 a code above 0xFFFF observerd
+        // and first pair is written, but no input consumed
+        nowide::uint16_t &state = *reinterpret_cast<nowide::uint16_t *>(&std_state);
+        while(to < to_end && from < from_end)
+        {
+#ifdef DEBUG_CODECVT            
+            std::cout << "Entering IN--------------" << std::endl;
+            std::cout << "State " << std::hex << state <<std::endl;
+            std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif           
+            char const *from_saved = from;
+            
+            uint32_t ch=nowide::utf::utf_traits<char>::decode(from,from_end);
+            
+            if(ch==nowide::utf::illegal) {
+                from = from_saved;
+                r=std::codecvt_base::error;
+                break;
+            }
+            if(ch==nowide::utf::incomplete) {
+                from = from_saved;
+                r=std::codecvt_base::partial;
+                break;
+            }
+            // Normal codepoints go direcly to stream
+            if(ch <= 0xFFFF) {
+                *to++=ch;
+            }
+            else {
+                // for  other codepoints we do following
+                //
+                // 1. We can't consume our input as we may find ourselfs
+                //    in state where all input consumed but not all output written,i.e. only
+                //    1st pair is written
+                // 2. We only write first pair and mark this in the state, we also revert back
+                //    the from pointer in order to make sure this codepoint would be read
+                //    once again and then we would consume our input together with writing
+                //    second surrogate pair
+                ch-=0x10000;
+                nowide::uint16_t vh = ch >> 10;
+                nowide::uint16_t vl = ch & 0x3FF;
+                nowide::uint16_t w1 = vh + 0xD800;
+                nowide::uint16_t w2 = vl + 0xDC00;
+                if(state == 0) {
+                    from = from_saved;
+                    *to++ = w1;
+                    state = 1;
+                }
+                else {
+                    *to++ = w2;
+                    state = 0;
+                }
+            }
+        }
+        from_next=from;
+        to_next=to;
+        if(r == std::codecvt_base::ok && (from!=from_end || state!=0))
+            r = std::codecvt_base::partial;
+#ifdef DEBUG_CODECVT            
+        std::cout << "Returning ";
+        switch(r) {
+        case std::codecvt_base::ok:
+            std::cout << "ok" << std::endl;
+            break;
+        case std::codecvt_base::partial:
+            std::cout << "partial" << std::endl;
+            break;
+        case std::codecvt_base::error:
+            std::cout << "error" << std::endl;
+            break;
+        default:
+            std::cout << "other" << std::endl;
+            break;
+        }
+        std::cout << "State " << std::hex << state <<std::endl;
+        std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif            
+        return r;
+    }
+    
+    virtual std::codecvt_base::result 
+    do_out( std::mbstate_t &std_state,
+            uchar const *from,
+            uchar const *from_end,
+            uchar const *&from_next,
+            char *to,
+            char *to_end,
+            char *&to_next) const
+    {
+        std::codecvt_base::result r=std::codecvt_base::ok;
+        // mbstate_t is POD type and should be initialized to 0 (i.a. state = stateT())
+        // according to standard. We assume that sizeof(mbstate_t) >=2 in order
+        // to be able to store first observerd surrogate pair
+        //
+        // State: state!=0 - a first surrogate pair was observerd (state = first pair),
+        // we expect the second one to come and then zero the state
+        ///
+        nowide::uint16_t &state = *reinterpret_cast<nowide::uint16_t *>(&std_state);
+        while(to < to_end && from < from_end)
+        {
+#ifdef DEBUG_CODECVT            
+        std::cout << "Entering OUT --------------" << std::endl;
+        std::cout << "State " << std::hex << state <<std::endl;
+        std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif            
+            nowide::uint32_t ch=0;
+            if(state != 0) {
+                // if the state idecates that 1st surrogate pair was written
+                // we should make sure that the second one that comes is actually
+                // second surrogate
+                nowide::uint16_t w1 = state;
+                nowide::uint16_t w2 = *from; 
+                // we don't forward from as writing may fail to incomplete or
+                // partial conversion
+                if(0xDC00 <= w2 && w2<=0xDFFF) {
+                    nowide::uint16_t vh = w1 - 0xD800;
+                    nowide::uint16_t vl = w2 - 0xDC00;
+                    ch=((uint32_t(vh) << 10)  | vl) + 0x10000;
+                }
+                else {
+                    // Invalid surrogate
+                    r=std::codecvt_base::error;
+                    break;
+                }
+            }
+            else {
+                ch = *from;
+                if(0xD800 <= ch && ch<=0xDBFF) {
+                    // if this is a first surrogate pair we put
+                    // it into the state and consume it, note we don't
+                    // go forward as it should be illegal so we increase
+                    // the from pointer manually
+                    state = ch;
+                    from++;
+                    continue;
+                }
+                else if(0xDC00 <= ch && ch<=0xDFFF) {
+                    // if we observe second surrogate pair and 
+                    // first only may be expected we should break from the loop with error
+                    // as it is illegal input
+                    r=std::codecvt_base::error;
+                    break;
+                }
+            }
+            if(!nowide::utf::is_valid_codepoint(ch)) {
+                r=std::codecvt_base::error;
+                break;
+            }
+            int len = nowide::utf::utf_traits<char>::width(ch);
+            if(to_end - to < len) {
+                r=std::codecvt_base::partial;
+                break;
+            }
+            to = nowide::utf::utf_traits<char>::encode(ch,to);
+            state = 0;
+            from++;
+        }
+        from_next=from;
+        to_next=to;
+        if(r==std::codecvt_base::ok && from!=from_end)
+            r = std::codecvt_base::partial;
+#ifdef DEBUG_CODECVT            
+        std::cout << "Returning ";
+        switch(r) {
+        case std::codecvt_base::ok:
+            std::cout << "ok" << std::endl;
+            break;
+        case std::codecvt_base::partial:
+            std::cout << "partial" << std::endl;
+            break;
+        case std::codecvt_base::error:
+            std::cout << "error" << std::endl;
+            break;
+        default:
+            std::cout << "other" << std::endl;
+            break;
+        }
+        std::cout << "State " << std::hex << state <<std::endl;
+        std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif            
+        return r;
+    }
+    
+};
+
+template<typename CharType>
+class utf8_codecvt<CharType,4> : public std::codecvt<CharType,char,std::mbstate_t>
+{
+public:
+    utf8_codecvt(size_t refs = 0) : std::codecvt<CharType,char,std::mbstate_t>(refs)
+    {
+    }
+protected:
+
+    typedef CharType uchar;
+
+    virtual std::codecvt_base::result do_unshift(std::mbstate_t &/*s*/,char *from,char * /*to*/,char *&next) const
+    {
+        next=from;
+        return std::codecvt_base::ok;
+    }
+    virtual int do_encoding() const throw()
+    {
+        return 0;
+    }
+    virtual int do_max_length() const throw()
+    {
+        return 4;
+    }
+    virtual bool do_always_noconv() const throw()
+    {
+        return false;
+    }
+
+    virtual int
+    do_length(  std::mbstate_t 
+    #ifdef NOWIDE_DO_LENGTH_MBSTATE_CONST
+            const   
+    #endif    
+            &/*state*/,
+            char const *from,
+            char const *from_end,
+            size_t max) const
+    {
+        #ifndef NOWIDE_DO_LENGTH_MBSTATE_CONST 
+        char const *start_from = from;
+        #else
+        size_t save_max = max;
+        #endif
+        
+        while(max > 0 && from < from_end){
+            char const *save_from = from;
+            nowide::uint32_t ch=nowide::utf::utf_traits<char>::decode(from,from_end);
+            if(ch==nowide::utf::incomplete || ch==nowide::utf::illegal) {
+                from = save_from;
+                break;
+            }
+            max--;
+        }
+        #ifndef NOWIDE_DO_LENGTH_MBSTATE_CONST 
+        return from - start_from;
+        #else
+        return save_max - max;
+        #endif
+    }
+
+    
+    virtual std::codecvt_base::result 
+    do_in(  std::mbstate_t &/*state*/,
+            char const *from,
+            char const *from_end,
+            char const *&from_next,
+            uchar *to,
+            uchar *to_end,
+            uchar *&to_next) const
+    {
+        std::codecvt_base::result r=std::codecvt_base::ok;
+        
+        // mbstate_t is POD type and should be initialized to 0 (i.a. state = stateT())
+        // according to standard. We use it to keep a flag 0/1 for surrogate pair writing
+        //
+        // if 0 no code above >0xFFFF observed, of 1 a code above 0xFFFF observerd
+        // and first pair is written, but no input consumed
+        while(to < to_end && from < from_end)
+        {
+#ifdef DEBUG_CODECVT            
+            std::cout << "Entering IN--------------" << std::endl;
+            std::cout << "State " << std::hex << state <<std::endl;
+            std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif           
+            char const *from_saved = from;
+            
+            uint32_t ch=nowide::utf::utf_traits<char>::decode(from,from_end);
+            
+            if(ch==nowide::utf::illegal) {
+                r=std::codecvt_base::error;
+                from = from_saved;
+                break;
+            }
+            if(ch==nowide::utf::incomplete) {
+                r=std::codecvt_base::partial;
+                from=from_saved;
+                break;
+            }
+            *to++=ch;
+        }
+        from_next=from;
+        to_next=to;
+        if(r == std::codecvt_base::ok && from!=from_end)
+            r = std::codecvt_base::partial;
+#ifdef DEBUG_CODECVT            
+        std::cout << "Returning ";
+        switch(r) {
+        case std::codecvt_base::ok:
+            std::cout << "ok" << std::endl;
+            break;
+        case std::codecvt_base::partial:
+            std::cout << "partial" << std::endl;
+            break;
+        case std::codecvt_base::error:
+            std::cout << "error" << std::endl;
+            break;
+        default:
+            std::cout << "other" << std::endl;
+            break;
+        }
+        std::cout << "State " << std::hex << state <<std::endl;
+        std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif            
+        return r;
+    }
+    
+    virtual std::codecvt_base::result 
+    do_out( std::mbstate_t &std_state,
+            uchar const *from,
+            uchar const *from_end,
+            uchar const *&from_next,
+            char *to,
+            char *to_end,
+            char *&to_next) const
+    {
+        std::codecvt_base::result r=std::codecvt_base::ok;
+        while(to < to_end && from < from_end)
+        {
+#ifdef DEBUG_CODECVT            
+        std::cout << "Entering OUT --------------" << std::endl;
+        std::cout << "State " << std::hex << state <<std::endl;
+        std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif            
+            nowide::uint32_t ch=0;
+            ch = *from;
+            if(!nowide::utf::is_valid_codepoint(ch)) {
+                r=std::codecvt_base::error;
+                break;
+            }
+            int len = nowide::utf::utf_traits<char>::width(ch);
+            if(to_end - to < len) {
+                r=std::codecvt_base::partial;
+                break;
+            }
+            to = nowide::utf::utf_traits<char>::encode(ch,to);
+            from++;
+        }
+        from_next=from;
+        to_next=to;
+        if(r==std::codecvt_base::ok && from!=from_end)
+            r = std::codecvt_base::partial;
+#ifdef DEBUG_CODECVT            
+        std::cout << "Returning ";
+        switch(r) {
+        case std::codecvt_base::ok:
+            std::cout << "ok" << std::endl;
+            break;
+        case std::codecvt_base::partial:
+            std::cout << "partial" << std::endl;
+            break;
+        case std::codecvt_base::error:
+            std::cout << "error" << std::endl;
+            break;
+        default:
+            std::cout << "other" << std::endl;
+            break;
+        }
+        std::cout << "State " << std::hex << state <<std::endl;
+        std::cout << "Left in " << std::dec << from_end - from << " out " << to_end -to << std::endl;
+#endif            
+        return r;
+    }
+};
+
+} // nowide
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/nowide/windows.hpp b/src/Plugins/Windows/nowide/windows.hpp
new file mode 100644
index 0000000..b9abff4
--- /dev/null
+++ b/src/Plugins/Windows/nowide/windows.hpp
@@ -0,0 +1,39 @@
+//
+//  Copyright (c) 2012 Artyom Beilis (Tonkikh)
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+#ifndef NOWIDE_WINDOWS_HPP_INCLUDED
+#define NOWIDE_WINDOWS_HPP_INCLUDED
+
+#include <stddef.h>
+
+#ifdef NOWIDE_USE_WINDOWS_H
+#include <windows.h>
+#else
+
+//
+// These are function prototypes... Allow to to include windows.h
+//
+extern "C" {
+
+__declspec(dllimport) wchar_t*        __stdcall GetEnvironmentStringsW(void);
+__declspec(dllimport) int             __stdcall FreeEnvironmentStringsW(wchar_t *);
+__declspec(dllimport) wchar_t*        __stdcall GetCommandLineW(void);
+__declspec(dllimport) wchar_t**       __stdcall CommandLineToArgvW(wchar_t const *,int *);
+__declspec(dllimport) unsigned long   __stdcall GetLastError();
+__declspec(dllimport) void*           __stdcall LocalFree(void *);
+__declspec(dllimport) int             __stdcall SetEnvironmentVariableW(wchar_t const *,wchar_t const *);
+__declspec(dllimport) unsigned long   __stdcall GetEnvironmentVariableW(wchar_t const *,wchar_t *,unsigned long);
+
+}
+
+#endif 
+
+
+
+#endif
+///
+// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
diff --git a/src/Plugins/Windows/win-utf8-compat.hpp b/src/Plugins/Windows/win-utf8-compat.hpp
new file mode 100644
index 0000000..513e50a
--- /dev/null
+++ b/src/Plugins/Windows/win-utf8-compat.hpp
@@ -0,0 +1,98 @@
+/******************************************************************************
+* MODULE     : win-utf8-compat.hpp
+* DESCRIPTION: The windows version of TeXmacs makes use of
+*              Boost.Nowide standalone library for accessing
+*              the Windows UTF-16 file API
+*******************************************************************************
+* As most application originating from the *nix world, TeXmacs
+* uses UTF-8 encoding for files names, file pathes and 
+* environment variables. Porting such applications to Windows
+* is complicated due to the fact that Windows API only accepts
+* UTF-16 for unicode.
+* 
+* Boost.Nowide provides an elegant light weight solution to this problem,
+* making porting from *nix to windows UTF-16 unicode API mostly transparent
+*
+* See http://cppcms.com/files/nowide/html/index.html
+*
+* Texmacs specific changes to the original Boost.Nowide standalone files dated 
+* 2017-Jun-10 are indicated in nowide/texmacs_modifications.patch
+* ****************************************************************************** 
+* LICENCE :
+* Boost.Nowide is released under Boost Software License - Version 1.0.
+* see https://www.boost.org/users/license.html
+******************************************************************************/
+
+#include "nowide/args.hpp"
+#include <sys/stat.h>
+
+typedef struct _stat32 struct_stat;
+
+#include "nowide/cstdio.hpp"
+#include "nowide/cenv.hpp"
+
+
+#ifndef S_ISLNK
+#define S_ISLNK(x) 0
+#endif
+
+#ifdef fopen
+ #undef fopen
+#endif
+ #define fopen(a,b) nowide::fopen(a,b)
+
+
+//do not redefine mkdir with single argument (url)
+//if two args point to nowide::mkdir
+#define GET_MACRO(_1,_2,NAME,...) NAME
+#define mkdir(...) GET_MACRO(__VA_ARGS__, nowide::mkdir, mkdir)(__VA_ARGS__)
+
+
+#ifdef opendir
+ #undef opendir
+#endif
+ #define opendir(a) nowide::opendir(a)
+ 
+#ifdef closedir
+ #undef closedir
+#endif
+#define closedir _wclosedir
+
+//typedef _WDIR DIR;
+#define DIR _WDIR
+ 
+#ifdef stat
+ #undef stat
+#endif
+#define stat(a,b) nowide::stat(a,b)
+//#define struct_stat GStatBuf
+//#define struct_stat _stat32 
+//#ifdef remove
+// #undef remove
+//#endif
+// #define ::remove nowide::remove
+
+#ifdef rename
+ #undef rename
+#endif
+ #define rename nowide::rename
+ 
+#ifdef chmod
+ #undef chmod
+#endif
+ #define chmod nowide::chmod
+
+#ifdef getenv
+ #undef getenv
+#endif
+ #define getenv nowide::getenv
+ 
+#ifdef setenv
+ #undef setenv
+#endif
+ #define setenv nowide::setenv
+
+#ifdef putenv
+ #undef putenv
+#endif
+ #define putenv nowide::putenv
diff --git a/src/System/Boot/init_texmacs.cpp b/src/System/Boot/init_texmacs.cpp
index 4f35e81..b5dea7a 100644
--- a/src/System/Boot/init_texmacs.cpp
+++ b/src/System/Boot/init_texmacs.cpp
@@ -20,6 +20,7 @@
 #include <unistd.h>
 #ifdef OS_MINGW
 #include <time.h>
+#include <direct.h>
 #endif
 
 tree texmacs_settings = tuple ();
diff --git a/src/System/Files/file.cpp b/src/System/Files/file.cpp
index 3741fd2..87894ef 100644
--- a/src/System/Files/file.cpp
+++ b/src/System/Files/file.cpp
@@ -24,12 +24,17 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-#include <dirent.h>
 #include <sys/stat.h>
 #include <sys/file.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <string.h>  // strerror
+#if defined (OS_MINGW)
+#include "Windows/win-utf8-compat.hpp"
+#else
+#include <dirent.h>
+#define struct_stat struct stat
+#endif
 
 #ifdef MACOSX_EXTENSIONS
 #include "MacOS/mac_images.h"
@@ -252,7 +257,7 @@ append_string (url u, string s, bool fatal) {
 ******************************************************************************/
 
 static bool
-get_attributes (url name, struct stat* buf,
+get_attributes (url name, struct_stat* buf,
 		bool link_flag=false, bool cache_flag= true)
 {
   // cout << "Stat " << name << LF;
@@ -357,13 +362,19 @@ is_of_type (url name, string filter) {
 
   // Normal files
 #ifdef OS_MINGW
-  if ((filter == "x") && (suffix(name) != "exe") && (suffix(name) != "bat"))
-    name = glue (name, ".exe");
+  string suf;
+  if (filter == "x") {
+    suf= suffix(name);
+    if ((suf != "exe") && (suf != "bat") && (suf != "com")) {
+      name = glue (name, ".exe");
+      suf = "exe";
+    }
+  }
 #endif
   bool preserve_links= false;
   for (i=0; i<n; i++)
     preserve_links= preserve_links || (filter[i] == 'l');
-  struct stat buf;
+  struct_stat buf;
   bool err= get_attributes (name, &buf, preserve_links);
   for (i=0; i<n; i++)
     switch (filter[i]) {
@@ -375,38 +386,22 @@ is_of_type (url name, string filter) {
       if (err || !S_ISDIR (buf.st_mode)) return false;
       break;
     case 'l':
-#ifdef OS_MINGW
-      return false;
-#else
       if (err || !S_ISLNK (buf.st_mode)) return false;
-#endif
       break;
     case 'r':
       if (err) return false;
-#ifndef OS_MINGW
       if ((buf.st_mode & (S_IRUSR | S_IRGRP | S_IROTH)) == 0) return false;
-#else
-      if ((buf.st_mode & 292) == 0) return false;
-#endif
       break;
     case 'w':
       if (err) return false;
-#ifndef OS_MINGW
       if ((buf.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0) return false;
-#else
-      if ((buf.st_mode & 146) == 0) return false;
-#endif
       break;
     case 'x':
       if (err) return false;
 #ifdef OS_MINGW
-      if (suffix(name) == "bat") break;
+      if (((suf == "exe") || (suf == "com") || (suf == "bat")) && (buf.st_mode & S_IRUSR)) return true;
 #endif
-#ifndef OS_MINGW
       if ((buf.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0) return false;
-#else
-      if ((buf.st_mode & 73) == 0) return false;
-#endif
       break;
     }
   return true;
@@ -420,7 +415,7 @@ int
 file_size (url u) {
   if (is_rooted_web (u)) return -1;
   if (is_rooted_tmfs (u)) return -1;
-  struct stat u_stat;
+  struct_stat u_stat;
   if (get_attributes (u, &u_stat, true)) return -1;
   return u_stat.st_size;
 }
@@ -431,7 +426,7 @@ last_modified (url u, bool cache_flag) {
     return - (int) (((unsigned int) (-1)) >> 1);
   if (is_rooted_tmfs (u))
     return - (int) (((unsigned int) (-1)) >> 1);
-  struct stat u_stat;
+  struct_stat u_stat;
   if (get_attributes (u, &u_stat, true, cache_flag))
     return - (int) (((unsigned int) (-1)) >> 1);
   return u_stat.st_mtime;
@@ -439,8 +434,8 @@ last_modified (url u, bool cache_flag) {
 
 bool
 is_newer (url which, url than) {
-  struct stat which_stat;
-  struct stat than_stat;
+  struct_stat which_stat;
+  struct_stat than_stat;
   // FIXME: why was this? 
   if (is_cached ("stat_cache.scm", concretize (which))) return false;
   if (is_cached ("stat_cache.scm", concretize (than))) return false;
@@ -535,11 +530,18 @@ read_directory (url u, bool& error_flag) {
   if (error_flag) return array<string> ();
 
   array<string> dir;
+  #ifdef OS_MINGW
+  while (true) {
+    const char* nextname =  nowide::readir_entry (dp);
+    if (nextname==NULL) break;
+    dir << string (nextname);
+  #else
   struct dirent* ep;
   while (true) {
     ep= readdir (dp);
     if (ep==NULL) break;
     dir << string (ep->d_name);
+  #endif
   }
   (void) closedir (dp);
   merge_sort (dir);
@@ -580,7 +582,11 @@ remove_sub (url u) {
   }
   else {
     c_string _u (concretize (u));
+#ifdef OS_MINGW
+    if (nowide::remove (_u) && DEBUG_AUTO) {
+#else
     if (::remove (_u) && DEBUG_AUTO) {
+#endif
       std_warning << "Remove failed: " << strerror (errno) << LF;
       std_warning << "File was: " << u << LF;
     }
@@ -610,11 +616,7 @@ mkdir (url u) {
 #if defined (HAVE_SYS_TYPES_H) && defined (HAVE_SYS_STAT_H)
   if (!exists (u)) {
     c_string _u (concretize (u));
-#ifdef OS_MINGW
-    (void) ::mkdir (_u);
-#else
     (void) ::mkdir (_u, S_IRWXU + S_IRGRP + S_IROTH);
-#endif
   }
 #else
 #ifdef OS_MINGW
diff --git a/src/System/Files/tm_ostream.cpp b/src/System/Files/tm_ostream.cpp
index ce87c94..42b588d 100644
--- a/src/System/Files/tm_ostream.cpp
+++ b/src/System/Files/tm_ostream.cpp
@@ -11,7 +11,13 @@
 
 #include "tm_ostream.hpp"
 #include "tree.hpp"
-
+#ifdef OS_MINGW
+#include "Windows/win-utf8-compat.hpp"
+#include "Windows/nowide/iostream.hpp"
+#include "Windows/nowide/convert.hpp"
+FILE* fstdout;
+FILE* fstderr; 
+#endif
 /******************************************************************************
 * Routines for abstract base class
 ******************************************************************************/
@@ -56,6 +62,10 @@ std_ostream_rep::std_ostream_rep (char* fn):
 {
   file= fopen (fn, "w");
   if (file) {
+#ifdef OS_MINGW
+    if (strcmp(fn, "stdout") == 0) fstdout = file; 
+    if (strcmp(fn, "stderr") == 0) fstderr = file;
+#endif
     is_w= true;
     is_mine= true;
   }
@@ -85,6 +95,17 @@ std_ostream_rep::is_writable () const {
 
 void
 std_ostream_rep::write (const char* s) {
+#ifdef OS_MINGW
+  if (file == fstdout) {
+      nowide::cout<<s ;
+      nowide::cout.flush();
+     }
+  else if (file == fstderr) {
+      nowide::cerr<<s ;
+      nowide::cerr.flush();
+     }
+  else
+#endif
   if (file && is_w) {
     if (0 <= fprintf (file, "%s", s)) {
       const char* c= s;
@@ -92,7 +113,7 @@ std_ostream_rep::write (const char* s) {
       if (*c == '\n') flush ();
     }
     else is_w= false;
-  }    
+  }
 }
 
 void
diff --git a/src/System/Misc/sys_utils.cpp b/src/System/Misc/sys_utils.cpp
index 13f8fb6..fcd829d 100644
--- a/src/System/Misc/sys_utils.cpp
+++ b/src/System/Misc/sys_utils.cpp
@@ -17,6 +17,7 @@
 #ifdef OS_MINGW
 #include "Qt/qt_sys_utils.hpp"
 #include "Windows/mingw_sys_utils.hpp"
+#include "Windows/win-utf8-compat.hpp"
 #else
 #include "Unix/unix_sys_utils.hpp"
 #endif
@@ -83,7 +84,7 @@ var_eval_system (string s) {
 string
 get_env (string var) {
   c_string _var (var);
-  char* _ret= getenv (_var);
+  const char* _ret= getenv (_var);
   if (_ret==NULL) {
     if (var == "PWD") return get_env ("HOME");
     return "";
diff --git a/src/Texmacs/Texmacs/texmacs.cpp b/src/Texmacs/Texmacs/texmacs.cpp
index 61d155b..7134e28 100644
--- a/src/Texmacs/Texmacs/texmacs.cpp
+++ b/src/Texmacs/Texmacs/texmacs.cpp
@@ -36,6 +36,10 @@ void mac_fix_paths ();
 #include <QDir>
 #endif
 
+#ifdef OS_MINGW
+#include "Windows/win-utf8-compat.hpp"
+#endif
+
 #ifdef MACOSX_EXTENSIONS
 #include "MacOS/mac_utilities.h"
 #endif
@@ -519,9 +523,11 @@ void
 immediate_options (int argc, char** argv) {
   if (get_env ("TEXMACS_HOME_PATH") == "")
 #ifdef OS_MINGW
+    {
     if (get_env ("HOME") == "")
         set_env ("HOME", get_env("USERPROFILE"));
     set_env ("TEXMACS_HOME_PATH", get_env ("APPDATA") * "\\TeXmacs");
+	}
 #else
     set_env ("TEXMACS_HOME_PATH", get_env ("HOME") * "/.TeXmacs");
 #endif
@@ -597,6 +603,10 @@ main (int argc, char** argv) {
   } else cerr << "Cannot get stack value\n";
 #endif
 
+#ifdef OS_MINGW
+	nowide::args a(argc,argv); // Fix arguments - make them UTF-8
+#endif
+
 
   original_path= get_env ("PATH");
   boot_hacks ();
diff --git a/src/Typeset/Concat/concat_active.cpp b/src/Typeset/Concat/concat_active.cpp
index cdd1f2c..2331213 100644
--- a/src/Typeset/Concat/concat_active.cpp
+++ b/src/Typeset/Concat/concat_active.cpp
@@ -326,7 +326,7 @@ concater_rep::typeset_image (tree t, path ip) {
   if (is_atomic (image_tree)) {
     if (N (image_tree->label) == 0)
       error_image (tree (WITH, "color", "red", "no image"));
-    url im= cork_to_os8bits (image_tree->label);
+    url im= cork_to_utf8( image_tree->label);
     image= resolve (relative (env->base_file_name, im));
     if (is_none (image) && suffix (im) == "")
       image= resolve (relative (env->base_file_name, ::glue (im, ".eps")));
